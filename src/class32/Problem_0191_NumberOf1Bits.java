package class32;

// 191. 位1的个数
public class Problem_0191_NumberOf1Bits {
    /**
     * 编写一个函数，输入是一个无符号整数（以二进制串的形式），
     * 返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
     */
    
    /**
     * 思路:
     * 解法1. 每次取出最右侧的1出来，计算到结果中，然后消掉最右侧的1，
     * 继续搞下一位
     */
    public int hammingWeight(int n) {
        int ans = 0;
        int rightOne = 0;
        while(n != 0) {
            ans++;
            rightOne = n & (-n);
            n ^= rightOne;
        }
        return ans;
    }
    
    /**
     * 解法2: 很多库的底层就是用的这种算法
     * 
     * 假设有一种数x只有2位, 如何求2位的二进制中1的个数? 
     * (x & 0x1) + ( (x >>> 1) & 0x1 ), 实际上, 
     * int类型是以 32位存储的. 所以对于同一个运算, 可以对
     * 整个32位的两两相邻的两位来求.... 以此类推, 合并相邻4位, 合并相邻8位, 合并相邻16位. 得到结果.
     * 
     * ===
     * 1. 32位数，每一位的含义拆开的,每一位的信息都是上面的二进制代表的10进制结果，
     * 比如1001 第一位是1，表示一个1，第四位是1，又表示一个1，总共2个1
     * 2. 两位一起看有几个1, 比如10 代表10进制数2, 有两个1
     * 3. 最终我们变成 32 位一起看，上面的值是 1 的个数
     * 
     * 整体流程:
     * 1.变成2位一起看
     * 2.变成4位一起看
     * 3.变成8位一起看
     * 4.变成16位一起看
     * 5.变成32位一起看
     * 
     * 例子: https://en.wikipedia.org/wiki/Hamming_weight
     * (背)
     */
    public static int hammingWeight2(int n) {
        // 0101 0101 0101 0101 0101 0101 0101 0101 -> 0x55555555
        n = (n & 0x55555555) + ((n >>> 1) & 0x55555555);
        // 0011 0011 0011 0011 0011 0011 0011 0011 -> 0x33333333
        n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);
        // 0000 1111 0000 1111 0000 1111 0000 1111 -> 0x0f0f0f0f
        n = (n & 0x0f0f0f0f) + ((n >>> 4) & 0x0f0f0f0f);
        // 0000 0000 1111 1111 0000 0000 1111 1111 -> 0x00ff00ff
        n = (n & 0x00ff00ff) + ((n >>> 8) & 0x00ff00ff);
        // 0000 0000 0000 0000 1111 1111 1111 1111 -> 0x0000ffff
        n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);
        return n;
    }
}
