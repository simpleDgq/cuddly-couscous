package class32;

// 190.颠倒二进制位
public class Problem_0190_ReverseBits {
    /**
     * 颠倒给定的 32 位无符号整数的二进制位。
     * 提示：
     * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，
     * 输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无
     * 论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     * 
     * 
     * 32 位的二进制状态逆序过来，得到一个状态，把这个代表的数字返回
     */
    
    /**
     * 思路:
     * 
     * 1.高16位与低16位交换
     * 2.高16位里面的高8位与低8位交换，低16位里面的高8位与低8位交换
     * 3.高8位里面的高4位与低4位交换，低8位里面的高4位与低4位交换
     * 4.高4位里面的高2位与低2位交换，低4位里面的高2位与低2位交换
     * 5.高2位里面的高1位与低1位交换，低2位里面的高1位与低1位交换
     * 
     * 详细解释:
     * // 代码看着很魔幻吧？
    // 给个例子，假设n二进制为：
    // 1011 0111 0011 1001 0011 1111 0110 1010 
    // 解释一下，第一行，是把n左边16位，和n右边16位交换
    // n = (n >>> 16) | (n << 16);
    // 因为 n >>> 16 就是左边16位被移动到了右侧
    // 同时 n << 16  就是右边16位被移动到了左侧
    // 又 | 在了一起，所以，n变成了
    // 0011 1111 0110 1010 1011 0111 0011 1001
    
    // 第二行，
    // n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
    // (n & 0xff00ff00)  
    // 这一句意思是，左侧开始算0~7位，保留；8~15位，全变0；16~23位，保留；24~31位，全变0
    // 0011 1111 0000 0000 1011 0111 0000 0000
    // (n & 0xff00ff00) >>> 8 这句就是上面的值，统一向右移动8位，变成：
    // 0000 0000 0011 1111 0000 0000 1011 0111
    //
    //
    // (n & 0x00ff00ff)
    // 这一句意思是，左侧开始算0~7位，全变0；8~15位，保留；16~23位，全变0；24~31位，保留
    // 0000 0000 0110 1010 0000 0000 0011 1001
    // (n & 0x00ff00ff) << 8 这句就是上面的值，统一向左移动8位，变成：
    // 0110 1010 0000 0000 0011 1001 0000 0000
    // 那么 ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8)
    // 什么效果？就是n的0~7位和8~15位交换了，16~23位和24~31位交换了
    // 0110 1010 0011 1111 0011 1001 1011 0111

    // 也就是说，整个过程是n的左16位，和右16位交换
    // n的左16位的内部，左8位和右8位交换；n的右16位的内部，左8位和右8位交换
    // 接下来的一行，其实是，从左边开始算，0~7位内部，左4和右4交换；8~15位，左4和右4交换；...
    // 接下来的一行，其实是，从左边开始算，0~3位内部，左2和右2交换；4~7位，左2和右2交换；...
    // 最后的一行，其实是，从左边开始算，0~1位内部，左1和右1交换；2~3位，左1和右1交换；...
     */
    
    public int reverseBits(int n) {
        //高16位和低16位的交换
        n = ((n >>> 16) | (n << 16)); // 高16位无符号右移(高位补0)，或上低16位左移 --> 完成高16位和低16位的交换
        // 16位里面的高8位与低8位交换
        // 1111 1111 0000 0000 1111 1111 0000 0000 ->  0xff00ff00
        // 0000 0000 1111 1111 0000 0000 1111 1111 ->  0x00ff00ff
        n = (((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8));// 分别取出高8位和低8位，然后交换
        // 8位里面的高4位与低4位交换
        // 1111 0000 1111 0000 1111 0000 1111 0000 -> 0xf0f0f0f0
        // 0000 1111 0000 1111 0000 1111 0000 1111 -> 0x0f0f0f0f
        n = (((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4));
        // 4位里面的高2位与低2位交换
        // 1100 1100 1100 1100 1100 1100 1100 1100 -> 0xcccccccc
        // 0011 0011 0011 0011 0011 0011 0011 0011 -> 0x33333333
        n = (((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2));
        // 2位里面的高1位与低1位交换
        // 1010 1010 1010 1010 1010 1010 1010 1010 -> 0xaaaaaaaa
        // 0101 0101 0101 0101 0101 0101 0101 0101 -> 0x55555555
        n = (((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1));
        return n;
    }
}
