package class32;

// 204. 计数质数
public class Problem_0204_CountPrimes {
    /**
     * 给定整数 n ，返回 所有小于非负整数 n 的质数的数量。
     * 
     * 质数又称素数。 一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数
     */
    
    /**
     * 思路:
     * 埃氏筛法
     * 
     * 操作：先把所有整数列出来，然后把2的倍数全部剔除，然后是3的，以此类推，
     * 遍历所有素数，把倍数全部划去。  
     * 对于每个数字i，如果没被划去，它一定是素数，因为它不是任何2到i-1数字的倍数。
     * 然后就开始划它的倍数就好。
     * 
     * 1. 跳过所有的偶数，2*1 2*2 2*3 ....
     * 2. 来到3，3 * 2是偶数，已经计算过，所以从3 * 3 开始
     *    3 * 4是偶数，也已经计算过，跳过
     *    --> 3 * 3  3 * 5  3 * 7 ..... 这些数都不是素数
     * 3. 来到4 4 * 任何数都是偶数，直接跳过
     * 4. 来到5 5 * 2 5 * 3, 5 * 4, 都计算过，所以从5 * 5开始
     *    --> 5 * 5  5 * 7  5 * 9 ..... 这些数都不是素数
     * 5. 来到6 4 * 任何数都是偶数，直接跳过
     * 6. 来到7 7 * 2，7 * 3, 一直到 7 * 7都试过，不用再试，
     *    从7 * 7开始 
     *    --> 7 * 7  7 * 9  7 * 11 ..... 这些数都不是素数
     * ....
     *  来到一个数j，考虑j * j 到 j * （j + 2）
     */ 
    public int countPrimes(int n) {
        if(n < 3) { //题目求得是 1 ~ n，到小于n的质数数量。 n=2的时候，虽然2是质数，但是2是不小于2的
            return 0;
        }
        // 某个数j已经不是素数了，f[j] = true;
        boolean f[] = new boolean[n]; // n个数需要标记
        // 所有偶数都不要，还剩几个数
        // n = 8， n / 2 = 4, 还剩4个数
        // n = 7， n / 2 = 3，还剩3个数，7是自己，不需要判断(题目要求小于n)，所以3是对的
        int count = n / 2;
        // 从3开始尝试，i每次加2
        // 3 5 7 9打头去尝试，i * i要小于n，i每次加2
        for(int i = 3; i * i < n; i += 2) {
            // 如果当前的i已经不是素数了，说明这个数不需要试了，去搞下一个数
            if(f[i]) {
                continue;
            }
            // 3 -> 3 * 3 = 9   3 * 5 = 15   3 * 7 = 21 -> 15等于9 + 2 * 3  21 = 15 + 2 * 3
            // 7 -> 7 * 7 = 49  7 * 9 = 63
            // 13 -> 13 * 13  13 * 15
            for(int j = i * i; j < n; j += 2 * i) {
                // 是倍数的位置，一定不是素数，标记
                if(!f[j]) {
                    --count;
                    f[j] = true;
                }
            }
        }
        return count;
    }
    
}
