package class19;

// 数位DP，频率不高，但是这题考过 --> 这种题目只能去背了
// 下面链接的是同一个题目
// https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/
// https://leetcode-cn.com/problems/number-of-digit-one/
public class Code03_OneNumber {
    /**
     * 剑指 Offer 43. 1～n 整数中 1 出现的次数
     * 
     * 给定一个正数N，比如N = 13，在纸上把所有数都列出来如下：
     *   1 2 3 4 5 6 7 8 9 10 11 12 13
     *   可以数出1这个字符出现了6次
     *   给定一个正数N，如果把1~N都列出来，
     *   返回1这个字符出现的多少次
     */
    
    /**
     * 
     * 大思路:
     * 假设N是12631
     *      2632~12631: 不递归, 自己算有多少个1
     *      1~2631: 递归
     *          632~2631: 不递归, 自己算
     *          1~631: 递归
     * 所有的答案加起来就是最终的答案
     * 每回剥掉一个数字, 剩下的数字加1 到 最后的数，自己算。
     * 
     * 分开讨论:
     * 1.最高位上1, 例如1364
     * 要求的是365~1364这些数，在最高位贡献几个1 --> 1000~1364 总共365个数
     * 2. 最高位上不是1，例如5372
     * 要求的是373~5372这些数，在最高位贡献几个1 --> 1000~1999 总共1000个数
     * 
     * 结论:
     * 最高位上贡献几个1
     *   以X开头的一个数: X.....
     *   先求的是剥去最高位X 剩下的数+1 ~ X这个范围上在最高位贡献几个1
     *   如果X是1: 贡献的数量就是剥去最高位X 剩下的数+1 --> 比如1364: 最高位是1, 能给最高位贡献364+1=365个1
     *   如果X>1: 最高位设置为1, 补齐后面0跟原数字位数一样这么多个1 -> 比如5372，最高位设置为1，补齐4位，是1000，能给最高位贡献1000个1
     * 
     * 上面讨论了最高位千位上能贡献的1的个数。那么百位，十位，个位上能贡献的1的个数有多少个?
     * 最高位上是1: 
     *  1364 , 要求的是365~1364这些数，在百位贡献几个1 --> 百位上是1, 10位上0~9这些数字你随意变，个位上0~9这个范围上的数字，你随意变
     *  ,调整千位是1或者0，总能在365~1364这个范围上 --> 总共10 * 10 = 100
     *  1364,  要求的是365~1364这些数，在十位贡献几个1 --> 十位是1, 百位，个位随意变, 都能通过千位的自适应，在这个范围上找到一个十位有1的数。
     *  --> 总共10 * 10 = 100个
     *  1364,  要求的是365~1364这些数，在个位贡献几个 --> 个位是1, 百位，十位随意变, 都能通过千位的自适应，在这个范围上找到一个十位有1的数。 
     *  --> 总共10 * 10 = 100个
     * 
     * 结论:
     * 如果最高位上是1, 数字整体有K个数, 1后面的部分值叫rest
     *  最高位贡献 rest+1个1
     *  剩下的有几位? K-1位, 每1位有几个1? (K-1)*10^{k-2}
     *
     * 如果最高位不是1，那么百位，十位，个位上能贡献的1的个数有多少个?
     *  5372， 要求的是373 ~ 5372这些数，在百位贡献几个1？
     *      373~5372 可以被划分为5个范围: 373~1372 1373~2372 2373~3372 3373~4372 4373~5372
     *      十位, 个位随意变, 在上面5个范围内每一个范围都可以通过千位的调整，让每一个范围有一个数出现
     *  5372， 要求的是373 ~ 5372这些数，在十位贡献几个1？ 如果十位必须是1, 十位, 个位随意变, 每一个范围有1个
     *  5372， 要求的是373 ~ 5372这些数，在个位贡献几个1？ 如果个位必须是1, 百位, 十位随意变, 每一个范围有1个
     * 结论:
     * 最高位X(X!=1), 后面剩下的部分是rest, 一共K个数, 最高位贡献10^{k-1}个1
     * 剩K-1位, 每个位上有几个1? X*10^{k-2}
     * 
     * 
     * 总的结论:(复习的时候直接记住这个结论吧，考的少)
     *  1) 如果最高位上是1, 数字整体有K个数, 1后面的部分值叫rest
     *     最高位贡献 rest+1个1
     *     剩下的有几位? K-1位, 每1位有几个1? (K-1)*10^{k-2}
     *  2) 最高位是X且X!=1, 后面剩下的部分是rest, 一共K个数, 最高位贡献10^{k-1}个1
     *     剩K-1位, 每个位上有几个1? X*10^{k-2}, 则剩下的k-1位贡献总共(K-1) * X*10^{k-2}个1
     */
    // 返回1~num这个范围上，1出现的次数
    public static int oneNumber(int num) {
        if(num < 1) { // 捣乱的数据
            return 0;
        }
        // 78676557766  11位
        // 10000000000  11位
        // 上面的例子，先求867655777 ~ 78676557766 有多少个1
        // 然后递归求1~8676557766 有多少个1
        
        // 几位数
        int len = getLengthOfNum(num);
        if(len == 1) { // 一位数，则只有1个1
            return 1;
        }
        // 78676557766  11位
        // 10000000000  11位
        int tmp1 = powerBaseOf10(len - 1); // 得到的就是 10000000000  11位
        // num最高位是num / tmp1
        int first = num / tmp1;
        // 最高位贡献多少个1. 如果最高位是1，则贡献rest+1个，rest就是num % tmp1
        // 最高位如果不是1，则贡献10^{k-1}个1, 也就是 10^{len - 1}个， 也就是tmp1
        int firstOneNumber = first == 1? num % tmp1 + 1: tmp1;
        // 除去最高位之后，剩下的数，贡献多少个1
        // 最高位是1:   (K-1) * 1 10^{k-2}
        // 最高位不是1: (K-1) * X * 10^{k-2}
        // 不管最高位是不是1，都满足(K-1) * X * 10^{k-2}，X就是最高位的数字
        int othersOneNumber = (len - 1) * first * powerBaseOf10(len - 2);
        // 1~(num % tmp1) 是前半部分，前半部分递归去搞
        return firstOneNumber + othersOneNumber +  oneNumber(num % tmp1);
    }
    
    public static int getLengthOfNum(int num) {
        int len = 0;
        while(num != 0) {
            len++;
            num /= 10;
        }
        return len;
    }
    public static int powerBaseOf10(int base) {
        return (int) Math.pow(10, base);
    }
}
