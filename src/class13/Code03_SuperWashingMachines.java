package class13;

//本题测试链接 : https://leetcode.com/problems/super-washing-machines/
public class Code03_SuperWashingMachines {
    /**
     * 假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

        在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。
        
        给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数。如果不能使每台洗衣机中衣物的数量相等，则返回 -1。
        
        示例 1：
        
        输入: [1,0,5]
        
        输出: 3
        
        解释: 
        第一步:    1     0 <-- 5    =>    1     1     4
        第二步:    1 <-- 1 <-- 4    =>    2     1     3    
        第三步:    2     1 <-- 3    =>    2     2     2   
        示例 2：
        
        输入: [0,3,0]
        
        输出: 2
        
        解释: 
        第一步:    0 <-- 3     0    =>    1     2     0    
        第二步:    1     2 --> 0    =>    1     1     1     
        示例 3:
        
        输入: [0,2,0]
        
        输出: -1
        
        解释: 
        不可能让所有三个洗衣机同时剩下相同数量的衣物。
        提示：
        
        n 的范围是 [1, 10000]。
        在每台超级洗衣机中，衣物数量的范围是 [0, 1e5]。
        
        
        ===另一种描述===
        有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打 包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人 将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最 小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同， 返回-1。 例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后:
        第一轮:1 0 <- 5 => 1 1 4 第二轮:1 <- 1 <- 4 => 2 1 3 第三轮:2 1 <- 3 => 2 2 2
        移动了3轮，每个机器上的物品相等，所以返回3
        例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品， 这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1
     */
    /**
     * 贪心
     * 
     * 思路:
     * 来到一个i位置，假设每台机器的衣服的数量我们知道
     * 算出i左边是多几件还是少几件，算出i右边多几件还是少几件
     * 四种情况:
     * 1) i 左边位置多 a 件，i右边 多b件, 每一轮都得将左右两边的衣服往i位置上班，bi如a=15，b=8，搬完8轮之后，左边还多7件，这
     * 时候还得把7搬到i，总共要15轮。 轮数: Math.max(a,b)
     * 2) i 左边位置少 a 件，i右边 多b件, a = -15, b = 8, 每一轮都往左边搬，右边的全搬过去，之后，左边还差7件，从i位置搬，总共
     *  需要15轮 。轮数: Math.max(abs(a),abs(b))
     * 3) i 左边位置多 a 件，i右边 少b件, a = 15, b = -8, 每一轮都往右边搬，搬了7件过去之后，左边还多7件，往i位置搬，总共
     *  需要15轮 。轮数: Math.max(abs(a),abs(b))
     * 4) i 左边位置少 a 件，i右边 少b件, a = -15, b = -8, 每一轮都得从i位置往两边搬，但是一轮只能搬往左边或者右边的一个位置搬
     * i搬去右边8件，需要8轮，然后搬去左边15件，需要15轮。轮数: abs(a)+abs(b)
     * 
     * 总结总共两种情况：
     * 1) 左边和右边都少衣服的时候，abs(a)+abs(b)
     * 2) 其它情况，Math.max(abs(a),abs(b))
     * 
     * 根据我们的策略。我们算出零位置时候的瓶颈要多少轮, 1位置时候的瓶颈要多少轮,
        2位置时候的瓶颈要多少轮, 每一个位置的瓶颈要多论。结论是所有答案中最痛的点求的max，决定了整体的瓶颈。
        因为当最痛瓶颈满足的同时，其他的瓶颈同步就解决了
        因为每一轮他都可以并行的搬。所以你最痛的瓶颈决定了一共的轮数。没有为什么数学证明很麻烦
     */
    public int findMinMoves(int[] machines) {
        if(machines == null || machines.length == 0) {
            return 0;
        }
        // 计算总体的衣服数量，如果和不能被均分，怎么也搞不定，返回-1
        int sum = 0;
        int N = machines.length;
        for(int i = 0; i <= N - 1; i++) {
          sum += machines[i];  
        }
        if(sum % N != 0) {
            return -1;
        }
        int avg = sum / N;
        int leftSum = 0; // i 左边的衣服总数, 一开始从0位置开始，0的左边没有衣服，所以是0
        int ans = 0;
        // 每一个i位置都去搞
        for(int i = 0; i <= N - 1; i++) {
            int leftRest = leftSum - i * avg; // 左边多多少，或者少多少
            int rightRest = (sum - leftSum) - machines[i] - (N - i - 1) * avg; // 右边多多少，或者少多少
            if(leftRest < 0 && rightRest < 0) { // 两边都少，只能从i搬
              ans = Math.max(ans, Math.abs(leftRest) + Math.abs(rightRest));  
            } else {
              ans = Math.max(ans, Math.max(Math.abs(leftRest), Math.abs(rightRest)));
            }
            leftSum += machines[i];
        }
        return ans;
    }
}
