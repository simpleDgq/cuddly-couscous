package class13;

public class Code01_NCardsABWins {
    // 谷歌面试题
    // 面值为1~10的牌组成一组，
    // 每次你从组里等概率的抽出1~10中的一张
    // 下次抽会换一个新的组，有无限组
    // 当累加和<17时，你将一直抽牌
    // 当累加和>=17且<21时，你将获胜
    // 当累加和>=21时，你将失败
    // 返回获胜的概率
    public static double f1() {
        return process(0); // 累加和从0开始，就是获胜的概率
    }
    // 当前的累加和是sum，你给我返回当前获胜的概率
    public static double process(int cur) {
        if(cur >= 17 && cur < 21) {
            return 1.0;
        }
        if(cur >= 21) {
            return 0.0;
        }
        double w = 0.0;
        // 下一步可能得到的累加和，每一种可能的累加和都去试，累加赢的概率
        for(int i = 1; i <= 10; i++) { // 假设累加和是11，赢的概率是a， 假设累加和是12，赢的概率是b --> 这里是计算的a+b
                                       // 但是来到11或者12，都有一个概率1/10. --> 所以返回之前要除10
            w += process(cur + i);
        }
        // 1 到 10每个数字抽到的概率都是1/10
        return w / 10;
    }
    
    // 谷歌面试题扩展版
    // 面值为1~N的牌组成一组，
    // 每次你从组里等概率的抽出1~N中的一张
    // 下次抽会换一个新的组，有无限组
    // 当累加和<a时，你将一直抽牌
    // 当累加和>=a且<b时，你将获胜
    // 当累加和>=b时，你将失败
    // 返回获胜的概率，给定的参数为N，a，b
    public static double f2(int N, int a, int b) {
        if(a < 0 || b < 0 || b <= a || N <= 0) { // a==b时候，不可能满足>=a && < b这个条件
            return 0.0;
        }
        if(b - a >= N) { // b = 6, a = 3, N = 2
           return 1.0;   // 赢的范围是3 4 5 6 , N = 2, 小于3的时候一直抽，在赢的区域就直接返回了，不可能有情况跳到>=6的位置 , 所以不可能输
        }
        return process2(0, N, a, b); // 累加和从0开始，就是获胜的概率
    }
    // 当前的累加和是sum，你给我返回当前获胜的概率
    public static double process2(int cur, int N, int a, int b) {
        if(cur >= a && cur < b) {
            return 1.0;
        }
        if(cur >= b) {
            return 0.0;
        }
        double w = 0.0;
        // 下一步可能得到的累加和，每一种可能的累加和都去试，累加赢的概率
        for(int i = 1; i <= N; i++) {
            w += process2(cur + i, N, a, b);
        }
        return w / N;
    }
    
    /**
     * 怎么省掉上面的for循环? 需要分析位置依赖
     * 举例子: N = 4的时候:
     * 1. 累加和到 5 的时赢的概率有多大，怎么算？把累加和6 的时候赢得概率a,
        把累加和7 的时候赢得概率b，把累加和8 的时候赢得概率c, 把累加和9 的
        时候赢得概率d, 我们要把a+b+c+d除一个N(4) 得到。
        
        累加和 4 的时赢的概率，把累加和5 的时候赢得概率x, 把累加和6 的时候
        赢得概率a, 把累加和7 的时候赢得概率b，把累加和8 的时候赢得概率c,
        我们要把x+a+b+c除一个N(4) 得到。
        
        x就是f(5); 所以f(4) = (f(5) + a + b + c) / 4 
        a+b+c = f(5) * 4 - d = f(5) * 4 - f(9) = f(5) * 4 - f(4 + 4 + 1)
        ==> f(4) = (f(5) + f(5) * 4 - f(N + 4 + 1)) / 4  ==> f(i) = (f(i + 1) + f(i+1)*N - f(N + i + 1)) / N;
        
      2. 上面的式子只适合离赢的区域比较远的时候，还需要分析一些，离赢的区域比较近的位置。
        1) 举例子: 假设N=6, a=18, b=21. 那么
        18,19, 20赢, 21以后输, 在赢得区域里面，它是不符合有公式的basecase, 直接1.0, 不符合公式
        2) 17位置，有哪些展开?
            +1得到18, +2到19, +3得到20, +4得到21, +5得到22, +6得到23
            18, 19, 20的概率是1.0, 21以后是0
            所以17的获胜概率是3/6=0.5
          => 1的通项公式在这个赢得区域的前一个位置失效
          ==> 17位置的通项公式是: (b - a) / N
        3) 16怎么算? 没有减去的那部分修正
         +1得到17, +2到18, +3得到19, +4得到20, +5得到21, +6得到22
         f(16) = (f(17) + f(18)+ f(19) + f(20)) / 6 = ( f(17) + f(17) * 6) / 6  --> 发现只是少了最后的减去的那部分修正
         
         15怎么算?14怎么算? --> 同16一样
        ===
        13怎么算? 开始符合1的公式
        也就是说从13开始及其左边所有的位置，符合一个普遍位置的公式，但是
        但是17单列14, 15, 16单列
     */
    public static double f3(int N, int a, int b) {
        if(a < 0 || b < 0 || b <= a || N <= 0) { // a==b时候，不可能满足>=a && < b这个条件
            return 0.0;
        }
        if(b - a >= N) { // b = 6, a = 3, N = 2
           return 1.0;   // 赢的范围是3 4 5 6 , N = 2, 小于3的时候一直抽，在赢的区域就直接返回了，不可能有情况跳到>=6的位置 , 所以不可能输
        }
        return process3(0, N, a, b); // 累加和从0开始，就是获胜的概率
    }
    // 当前的累加和是sum，你给我返回当前获胜的概率
    public static double process3(int cur, int N, int a, int b) {
        if(cur >= a && cur < b) {
            return 1.0;
        }
        if(cur >= b) {
            return 0.0;
        }
        if(cur == a - 1) {
            return 1.0 * ((b - 1) / N);
        }
        double w = process3(cur + 1, N, a, b) + process3(cur + 1, N, a, b) * N;
        // 需要修正的位置, 例子中就是13往前的位置
        if(cur + N + 1 < b) {
           w -= process3(N + cur + 1, N , a, b);
        }
        return w / N;
    }
    
    /**
     * 动态规划:
     * 可变参数: cur
     * 范围: 通项公式有三个，有个下标i，都是在整个数组上玩，不会超过b，所以是
     * boolean dp[b]
     * 启示
        1. 看到枚举行为，想想能不能通过观察的方式把枚举行为替掉。
        2. 推的时候多观察有限几个位置加加减减有可能能搞出来。但是从basecase开始最初一小段可能需要重点关注扣边界
        3. 遇到这种题别慌。先看一下数据量, 如果数据量很小, 不需要改动态规划, 写一个暴力递归就过了, 就没有必要再过后续的优化了。
     */
    public static double f4(int N, int a, int b) {
        if(a < 0 || b < 0 || b <= a || N <= 0) { // a==b时候，不可能满足>=a && < b这个条件
            return 0.0;
        }
        if(b - a >= N) { // b = 6, a = 3, N = 2
           return 1.0;   // 赢的范围是3 4 5 6 , N = 2, 小于3的时候一直抽，在赢的区域就直接返回了，不可能有情况跳到>=6的位置 , 所以不可能输
        }
       
        double dp[] = new double[b];
//        dp[b] = 0.0; // >=b赢的概率是0. 默认就是0.可以不写
        for(int i = a; i <= b - 1; i++) { // a ~ b可以赢的区域
           dp[i] = 1.0; 
        }
        if(a - 1 >= 0) { // a-1 位置
            dp[a - 1] = 1.0 * ((b - 1) / N);
        }
        // 从右往左填
        for(int i = a - 2; i >= 0; i--) {
            double w = dp[i + 1] + dp[i + 1] * N; // a-2 及其往左的位置
            if(i + N + 1 < b) { // 需要修正的位置
               w -= dp[N + i + 1];
            }
            dp[i] = w / N;
        }
        return dp[0];
    }
   
}
