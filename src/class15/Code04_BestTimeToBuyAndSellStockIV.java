package class15;

// https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/
public class Code04_BestTimeToBuyAndSellStockIV {
    /**
     * 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
        设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
        注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
     */
    
    /**
     * 思路:
     * 交易次数不能超过K次。
     * 
     * 1. 大的过滤: 如果最多的交易次数K>=N/2, 等同于交易次数不限, 等同于股票问题2
     * 证明:
     * 一个长度为N的数组中, 爬坡最多N/2。 爬坡最多的情况就是两个相邻的数数，上坡之后，直接下坡
     * 例如[1,3,1,3]这个例子就是爬坡数最多的情况 -> 长度为4，最多有2个坡，爬坡最多的情况都没有超过N/2
     * 所以，当K大于等于N/2的时候，就相当于不限制交易次数，等价于股票问题2。
     *
     * 2. 动态规划: 从左往右的尝试模型
     * dp[i][j] = 0到i位置上，交易次数不超过j次，能获得的最大收益
     * 最终的答案就是右下角位置，dp[N - 1][K] -> 0 到 N - 1位置上，交易次数不超过K次，能获得的最大收益。
     * 
     * 1) 0行: 0到0位置上，做0次交易，能获得的收益，是0，一次交易也不做，能获得个鸡儿。
     *         0到0位置上，做1次交易，能获得的收益，是0，买了就直接卖，能获得个鸡儿。
     *         0到0位置上，做2次交易，能获得的收益，是0，买了就直接卖，能获得个鸡儿。
     *         ...
     *         所以0行全是0. 数组默认是0，不用填。
     *    0列: 0到0位置上，做0次交易，能获得的收益，是0，一次交易也不做，能获得个鸡儿。
     *         0到1位置上，做0次交易，能获得的收益，是0，一次交易也不做，能获得个鸡儿。
     *         ...
     *         所以0列全是0. 数组默认是0，不用填。
     * 2) 普遍位置: dp[8][3] :  0 到 8 位置，不超过3次，能获得的最好收益
     *    可能性划分, 8位置要不要参与交易
     *    1) 8位置不参与， dp[7][3]  ->  0 到 7 位置，不超过3次交易，能获得的最好答案，就是dp[8][3] ： 
     *    2) 8位置要参与交易, 只能是最后一次交易的卖出时机
     *          8 位置参与, 最后一次交易是啥?
     *           最后一次交易买入时机的可能性:
     *           1) 8位置买入, 8位置卖出->  要求0~8位置，交易次数不能超过两次，因为8买8卖用了一次: dp[8][2] + arr[8] - arr[8]
     *           2) 7位置买入, 8位置卖出 -> 要求0~7位置，交易次数不能超过两次: dp[7][2] + arr[8] - arr[7]
     *           3) 6位置买入, 8位置卖出 -> dp[6][2] + arr[8] - arr[6]
     *           4) 5位置买入, 8位置卖出 -> dp[5][2] + arr[8] - arr[5]
     *           5) 4位置买入, 8位置卖出 -> dp[4][2] + arr[8] - arr[4]
     *           6) 3位置买入, 8位置卖出 -> dp[3][2] + arr[8] - arr[3]
     *           7) 2位置买入, 8位置卖出 -> dp[2][2] + arr[8] - arr[2]
     *           8) 1位置买入, 8位置卖出 -> dp[1][2] + arr[8] - arr[1]
     *           9) 0位置买入, 8位置卖出 -> dp[0][2] + arr[8] - arr[0]
     * 
     * 发现有枚举行为，需要斜率优化:         
     * 
     * 举例子: 
     * dp[5][2] : 要求0~5位置，交易次数不能超过两次，能获得的最好收益
     * 
     * 1) 5位置不参与，dp[4][2]
     * 2) 5位置参与
     *         1) 5位置买入, 5位置卖出->  要求0~5位置，交易次数不能超过1次，因为5买5卖用了1次。 dp[5][1] + arr[5] - arr[5]
     *         2) 4位置买入, 5位置卖出->  要求0~4位置，交易次数不能超过1次，因为4买5卖用了1次。 dp[4][1] + arr[5] - arr[4]
     *         3) 3位置买入, 5位置卖出->  要求0~5位置，交易次数不能超过1次，因为3买5卖用了1次。 dp[3][1] + arr[5] - arr[3]
     *         4) 2位置买入, 5位置卖出->  要求0~5位置，交易次数不能超过1次，因为2买5卖用了1次。 dp[2][1] + arr[5] - arr[2]
     *         5) 1位置买入, 5位置卖出->  要求0~5位置，交易次数不能超过1次，因为1买5卖用了1次。 dp[1][1] + arr[5] - arr[1]
     *         6) 0位置买入, 5位置卖出->  要求0~5位置，交易次数不能超过1次，因为0买5卖用了1次。 dp[0][1] + arr[5] - arr[0]
     *
     * 所有的可能性求max，就是 dp[5][2] 的答案。  
     *      
     * dp[6][2] : 要求0~6位置，交易次数不能超过两次，能获得的最好收益        
     * 
     * 1) 6位置不参与，dp[5][2]
     * 2) 6位置参与
     *         1) 6位置买入, 6位置卖出->  要求0~6位置，交易次数不能超过1次，因为6买6卖用了1次。 dp[6][1] + arr[6] - arr[6]
     *         ===下面这坨可以想办法用dp[4][2]表示===
     *         2) 5位置买入, 6位置卖出->  要求0~5位置，交易次数不能超过1次，因为5买6卖用了1次。 dp[5][1] + arr[6] - arr[5]
     *         3) 4位置买入, 6位置卖出->  要求0~4位置，交易次数不能超过1次，因为4买6卖用了1次。 dp[4][1] + arr[6] - arr[4]
     *         4) 3位置买入, 6位置卖出->  要求0~3位置，交易次数不能超过1次，因为3买6卖用了1次。 dp[3][1] + arr[6] - arr[3]
     *         5) 2位置买入, 6位置卖出->  要求0~2位置，交易次数不能超过1次，因为2买6卖用了1次。 dp[2][1] + arr[6] - arr[2]
     *         6) 1位置买入, 6位置卖出->  要求0~1位置，交易次数不能超过1次，因为1买6卖用了1次。 dp[1][1] + arr[6] - arr[1]
     *         7) 0位置买入, 6位置卖出->  要求0~0位置，交易次数不能超过1次，因为0买6卖用了1次。 dp[0][1] + arr[6] - arr[0]
     *
     * 所有的可能性求max，就是 dp[6][2] 的答案。
     *   
     * 很烦，本来想用dp[5][2]搞出dp[6][2], 但是发现dp[5][2] 的枚举加的是arr[5], 而dp[6][2] 加的是arr[6], 没办法搞定。
     * 
     * 求dp[5][2]的时候，我们可以先不加arr[5], 每种可能性不加arr[5]的情况下，先求出一个best出来，最后再加上arr[5]，再和dp[4][2] 去PK，就能得到dp[5][2]的答案。
     * 求出来的best就可以用来搞dp[6][2]，best先和dp[6][1]-arr[6] 去PK, 搞出一个新的best，best加上arr[6], 不就是6位置参与的情况下，下面那坨枚举的替代吗？ 
     * 然后在和dp[5][2] PK 就得到了dp[6][2]的答案。
     * 
     * 
     * 填表的时候，是一列一列的填，因为dp[6][2] 依赖 dp[5][2]。
     */
    
    public int maxProfit(int k, int[] prices) {
        if(prices == null || prices.length == 0 || k < 1) {
            return 0;
        }
        // 大的过滤
        int N = prices.length;
        if(k >= N / 2) {
            return maxProfitII(prices);
        }
        // 动态规划
        int dp[][] = new int[N][k + 1];
        // 一列一列填
        for(int j = 1; j <= k; j++) {
            // 先填好dp[1][j], 然后用dp[1][j]去替代dp[2][j]
            // 0到1位置，不超过j次，能获得的最大收益?
            // 1) 1位置完全不参与, 等价于0到0位置，不超过j次
            int p1 = dp[0][j];
            // 2) 1买入，1卖出, dp[1][j - 1] + prices[1] - prices[1]
            // 3) 0买入，1卖出,dp[0][j - 1] + prices[1] - prices[0]
            int best = Math.max(dp[1][j - 1] - prices[1], dp[0][j - 1] - prices[0]); // 搞定best，可以用来继续求dp[2][j]的值
            // best + prices[1] 和 dp[0][j] PK，最大值就是dp[1][j]
            dp[1][j] = Math.max(best + prices[1], p1);
            
            for(int i = 2; i <= N - 1; i++) {
                // i位置完全不参与, 等价于0到i位置，不超过j次
                p1 = dp[i - 1][j];
                // i买i卖，dp[i][j-1] + prices[i] - prices[i]  -> 这次的，是枚举里面多出的，需要和前面求出来的best PK
                best = Math.max(best, dp[i][j-1] - prices[i]);
                dp[i][j] = Math.max(best + prices[i], p1);
            }
        }
        return dp[N - 1][k];
    }
    
    public int maxProfitII(int[] prices) {
        if(prices == null || prices.length == 0) {
            return 0;
        }
        int ans = 0;
        int N = prices.length;
        for(int i = 1; i <= N - 1; i++) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }
}
