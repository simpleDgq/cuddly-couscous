package class07;

public class Code01_MaxAndValue {
    
    /*
     * 
     * 给定一个非负数组成的数组，长度一定大于1
        想知道数组中哪两个数&的结果最大
        返回这个最大结果

           时间复杂度O(N),额外空间复杂度O(1)
     */
    

    // O(N)的解
    // 因为是正数，所以不用考虑符号位(31位)
    // 首先来到30位，假设剩余的数字有N个(整体)，看看这一位是1的数，有几个
    // 如果有0个、或者1个
    // 说明不管怎么在数组中选择，任何两个数&的结果在第30位上都不可能有1了
    // 答案在第30位上的状态一定是0，
    // 保留剩余的N个数，继续考察第29位，谁也不淘汰(因为谁也不行，干脆接受30位上没有1的事实)
    // 如果有2个，
    // 说明答案就是这两个数(直接返回答案)，因为别的数在第30位都没有1，就这两个数有。
    // 如果有>2个，比如K个
    // 说明答案一定只用在这K个数中去选择某两个数，因为别的数在第30位都没有1，就这K个数有。
    // 答案在第30位上的状态一定是1，
    // 只把这K个数作为剩余的数，继续考察第29位，其他数都淘汰掉
    // .....
    // 现在来到i位，假设剩余的数字有M个，看看这一位是1的数，有几个
    // 如果有0个、或者1个
    // 说明不管怎么在M个数中选择，任何两个数&的结果在第i位上都不可能有1了
    // 答案在第i位上的状态一定是0，
    // 保留剩余的M个数，继续考察第i-1位
    // 如果有2个，
    // 说明答案就是这两个数(直接返回答案)，因为别的数在第i位都没有1，就这两个数有。
    // 如果有>2个，比如K个
    // 说明答案一定只用在这K个数中去选择某两个数，因为别的数在第i位都没有1，就这K个数有。
    // 答案在第i位上的状态一定是1，
    // 只把这K个数作为剩余的数，继续考察第i-1位，其他数都淘汰掉
    public static int maxAndValue(int arr[]) {
        if(arr == null || arr.length == 0) {
            return 0;
        }
        
        int M = arr.length; // 指向垃圾区的边界
        int ans = 0;
        for(int bit = 30; bit >= 0; bit--) {
            int temp = M; // 记录下垃圾区的位置，当一个数也不淘汰的时候，恢复M，去搞下一个bit位
            int i = 0;
            
            while(i < M) { // 每次只在非垃圾区遍历
                if((arr[i] & (1 << bit)) == 0) { // 当前数的bit位是0
                   swap(i, --M, arr); // 放入垃圾区
                } else {
                    i++; // 当前数的bit位是1，保留
                }
            }
            
            if(M == 2) { // 当前位是1的数，只剩两个了
                return arr[0] & arr[1];
            }
            
            if(M < 2) { // 当前位只有1个或0个，这时候当前最高位不可能搞出1，一个数也不淘汰
                M = temp;
            } else { // 高位是1的数> 2, 在非垃圾区，当前位答案一定是1, 收集答案，然后看剩下的数的下一位
                ans |= (1 << bit);
            }
        }
        return ans;
    }
    
    public static void swap(int i, int j, int arr[]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    
    // O(N^2)的暴力解
    public static int maxAndValue1(int[] arr) {
        int N = arr.length;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                max = Math.max(max, arr[i] & arr[j]);
            }
        }
        return max;
    }
}
