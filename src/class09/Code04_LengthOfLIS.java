package class09;

//本题测试链接 : https://leetcode.com/problems/longest-increasing-subsequence
// 300. 最长递增子序列
public class Code04_LengthOfLIS {
    /* 最长递增子序列的长度
     *  给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
        子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
        
        示例 1：
        ```
        输入：nums = [10,9,2,5,3,7,101,18]
        输出：4
        解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
        示例 2：
        
        输入：nums = [0,1,0,3,2,3]
        输出：4
        示例 3：
        
        输入：nums = [7,7,7,7,7,7,7]
        输出：1
        ```
        
        提示：
        
        1 <= nums.length <= 2500
        -104 <= nums[i] <= 104
        
        进阶：
        
        你可以设计时间复杂度为 O(n2) 的解决方案吗？
        你能将算法的时间复杂度降低到 O(n log(n)) 吗?
     */
    /**
     * O(N^2)的解法
     * dp[i]:
     * 子序列必须以i位置的数结尾的情况下，最长递增子序列是多长？整个中求max就是答案
     * 求每个dp[i]的时候: 每个数都去找左边谁比你小的所有的数，其中最大的dp值加1得到自己。
     * 
     * 每一个数都要去左边找比自己小的所有的数，每个数来一遍，时间复杂度就是O(N^2)
     * 
     * 优化：不是很好想到，背吧  --> 下面的写法好理解。掌握
     * 贪心： 我们要尽量让序列“增长地更慢”，即保证序列中的元素尽可能小，增加后续元素扩展序列的可能性。
     * 为此维护一个辅助数组 end，其中 end[i] 表示长度为 i+1 的所有递增子序列中末尾元素的最小值。
     *
     * 遍历原数组 nums，对于每个元素:
     * 1.如果当前元素 nums[i] 大于 end 的最后一个元素，则将其添加到 end 的末尾，因为它可以扩展当前最长的递增子序列。
     * 2.如果 nums[i] 小于或等于 end 的最后一个元素，则使用二分搜索找到第一个不小于 nums[i] 的元素在 end 中的位置，并替换它。
     * 这样做是为了保持 end 中元素尽可能小，增加后续元素扩展序列的可能性。
     * 
     * 
     */
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int N = nums.length;
        int end[] = new int[N]; // end[i]: 所有长度为i+1的递增子序列中的末尾元素中的最小值
        end[0] = nums[0]; // 所有长度为1的递增子序列中的末尾元素的最小值是arr[0]. 后面有可能被更新，从arr[0]开始
        int arrlength = 1;

        for (int i = 1; i <= N - 1; i++) {
            // 如果当前元素 nums[i] 大于 end 的最后一个元素, 说明添加这个元素之后，可以扩充当前的最长递增子序列
            // 则添加
            if(nums[i] > end[arrlength - 1]) { 
                end[arrlength] = nums[i];
                arrlength++;
            } else { //当前元素小于end的最后一个元素，则去end里面找一个位置，插入进去，保持 end 中元素尽可能小，增加后续元素扩展序列的可能性。
                int left = binarySearch(end, 0, arrlength - 1, nums[i]);
                end[left] = nums[i]; // 替换
            }
        }
        return arrlength;
    }
    /* // 在ends[l...r]范围上二分
    * // 如果 当前数(arr[i]) > ends[m]，砍掉左侧
    * // 如果 当前数(arr[i]) <= ends[m]，砍掉右侧
    * // 整个二分就是在ends里寻找 >= 当前数(arr[i])的最左位置

    * // 如果ends中不存在 >= 当前数(arr[i])的情况，将返回有效区的越界位置
    * // 也就是从while里面出来时，l所在的位置，是有效区的越界位置
    * // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
    * // 如果当前数为8, 从while里面出来时，l将来到2位置，指向的是比它大的元素的最左位置
    * // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
    * //如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，4位置
    */ 
    // 在 end 数组的有效范围内进行二分查找，找到第一个大于 nums[i] 的位置或者插入 nums[i] 的位置
    public int binarySearch(int end[], int left, int right, int target) {
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (target <= end[mid]) { // 如果target比end的中点小，继续去左边找
                right = mid - 1;
            } else { // target小于当前数，继续去右边找
                left = mid + 1;
            }
        }
        return left;// left要么指向越界位置，要么指向要替换的位置
    }
    
    /** // zuo神的写法，不太好理解，其实和上面的写法是一样
     * O(N^2)的解法
     * dp[i]:
     * 子序列必须以i位置的数结尾的情况下，最长递增子序列是多长？整个中求max就是答案
     * 求每个dp[i]的时候: 每个数都去找左边谁比你小的所有的数，其中最大的dp值加1得到自己。
     * 
     * 每一个数都要去左边找比自己小的所有的数，每个数来一遍，时间复杂度就是O(N^2)
     * 
     * 优化：不是很好想到，背吧
     * 贪心： 我们要尽量让序列“增长地更慢”，即保证序列中的元素尽可能小，增加后续元素扩展序列的可能性。
     * 为此维护一个辅助数组 end，其中 end[i] 表示长度为 i+1 的所有递增子序列中末尾元素的最小值。
     * 
     * 具体实现：
     * 来到一个i的时候，做一个二分在ends里有效区寻找 >= 当前数(arr[i])的最左位置，
     * 如果l越界，说明ends中没有大于等于当前数的数，说明递增子序列长度可以扩充1，直接扩充end有效区，填好新的ends[l]；
     * 如果l不越界，说明ends中有大于等于当前数的数，ends[l]需要更新成更小的值，那么就更可能搞出一个更长的上升序列。
     */
    public static int lengthOfLIS2(int arr[]) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int N = arr.length;
        int ends[] = new int[N]; // ends[i]: 目前所有长度为i+1的递增子序列中的末尾元素中的最小值.
        ends[0] = arr[0]; // 初始状态，刚开始长度为1的递增子序列中的最小结尾就是arr[0]
        
        int right = 0; // 记录有效区的右边界
        int mid = 0;
        int max = 1; // 最长递增子序列的长度至少是1
        for(int i = 1; i <= N - 1; i++) { // 剩下的数字区去遍历
            int l = 0;
            int r = right;
            // 每一个数字搞一个二分，找ends有效区中，比当前数大的最左位置
            // 在 end 数组的有效范围内进行二分查找，找到第一个大于 nums[i] 的位置或者插入 nums[i] 的位置
            while(l <= r) {
                mid = l + ((r - l) >> 1);
                if(arr[i] <= ends[mid]) { // ends[mid] 大于等于当前数字，去左边继续找。找大于等于arr[i]的最左位置。 举例子（3, 5, 9, 12） -> 要找8, 8比9小，需要找比它大的最左位置，继续去左边找
                    r = mid - 1;
                } else {  // ends[mid]小于等于arr[i]，去右边继续找比当前数大的数。 举例子（3, 5, 9, 12） -> 10 比9大，继续去右边找
                    l = mid + 1;
                }
            }
            // 在ends[l...r]范围上二分
            // 如果 当前数(arr[i]) > ends[m]，砍掉左侧
            // 如果 当前数(arr[i]) <= ends[m]，砍掉右侧
            // 整个二分就是在ends里寻找 >= 当前数(arr[i])的最左位置
            // 就是从while里面出来时，l所在的位置。
            // 如果ends中不存在 >= 当前数(arr[i])的情况，将返回有效区的越界位置
            // 也就是从while里面出来时，l所在的位置，是有效区的越界位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为8, 从while里面出来时，l将来到2位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，4位置
            // l 的值现在指向第一个大于 nums[i] 的位置或者 end 数组的末尾（如果 nums[i] 大于所有已有的末尾元素）  
            // 更新这个位置（或末尾）的值为 nums[i]，以保证 end 数组保持递增且尽可能小
            right = Math.max(l, right);
            // 更新ends[l]的值
            ends[l] = arr[i];
            // 收集i位置对应的答案，PK出max
            max = Math.max(l + 1, max);//l指向数组最后的时候，递增子序列长度是l+1
        }
        return max;
    }
}
