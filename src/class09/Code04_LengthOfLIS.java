package class09;

//本题测试链接 : https://leetcode.com/problems/longest-increasing-subsequence
public class Code04_LengthOfLIS {
    /* 最长递增子序列的长度
     *  给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
        子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
        
        示例 1：
        ```
        输入：nums = [10,9,2,5,3,7,101,18]
        输出：4
        解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
        示例 2：
        
        输入：nums = [0,1,0,3,2,3]
        输出：4
        示例 3：
        
        输入：nums = [7,7,7,7,7,7,7]
        输出：1
        ```
        
        提示：
        
        1 <= nums.length <= 2500
        -104 <= nums[i] <= 104
        
        进阶：
        
        你可以设计时间复杂度为 O(n2) 的解决方案吗？
        你能将算法的时间复杂度降低到 O(n log(n)) 吗?
     */
    
    /**
     * O(N^2)的解法
     * dp[i]:
        子序列必须以i位置的数结尾的情况下，最长递增子序列是多长？整个中求max就是答案
        求每个dp[i]的时候: 每个数都去找左边谁比你小的所有的数，其中最大的dp值加1得到自己。
        
        每一个数都要去左边找比自己小的所有的数，每个数来一遍，时间复杂度就是O(N^2)
     */
    
    /**
     *  O(N*logN)的解法
     *  
     *  有没有方法得到dp[i]的值不通过遍历？
     *  
     *  申请辅助数组ends, ends[i]: 目前所有长度为i+1的递增子序列中的最小结尾.
     *  
     *  来到一个i的时候，做一个二分在ends里有效区寻找 >= 当前数(arr[i])的最左位置，
     *  如果l越界，说明ends中没有大于等于当前数的数，说明递增子序列长度可以扩充1，直接扩充end有效区，填好新的ends[l]；
     *  如果l不越界，说明ends中有大于等于当前数的数，ends[l]需要更新成最小值。
     *  
     *  (直接看zuoshen代码里面的例子理解)
     */
    
    public static int lengthOfLIS(int arr[]) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int N = arr.length;
        int ends[] = new int[N]; // ends[i]: 目前所有长度为i+1的递增子序列中的最小结尾.
        ends[0] = arr[0]; // 初始状态，刚开始长度为1的递增子序列中的最小结尾就是arr[0]
        
        int right = 0; // 记录有效区的右边界
        int mid = 0;
        int max = 1; // 最长递增子序列的长度至少是1
        for(int i = 1; i <= N - 1; i++) { // 剩下的字符取遍历
            int l = 0;
            int r = right;
            // 每一个字符搞一个二分，找ends有效区中，比当前数大的最左位置
            while(l <= r) {
                mid = l + ((r - l) >> 1);
                if(arr[i] <= ends[mid]) { // ends[mid] 大于等于当前数字，去左边继续找。找大于等于arr[i]的最左位置。 举例子（3, 5, 9, 12） -> 要找8, 8比9小，需要找比它大的最左位置，继续去左边找
                    r = mid - 1;
                } else {  // ends[mid]小于等于arr[i]，去右边继续找比当前数大的数。 举例子（3, 5, 9, 12） -> 10 比9大，继续去右边找
                    l = mid + 1;
                }
            }
            // 如果ends中不存在 >= 当前数(arr[i])的情况，将返回有效区的越界位置
            // 也就是从while里面出来时，l所在的位置，是有效区的越界位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为8, 从while里面出来时，l将来到2位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，4位置
            
            // 看有效区有没有扩大
            // 如果l越界了，说明扩大了，如果没有越界，说明没有扩大
            right = Math.max(l, right);
            // 更新ends[l]的值
            ends[l] = arr[i];
            // 收集i位置对应的答案，PK出max
            max = Math.max(l + 1, max);
        }
        return max;
    }
}
