package class20;

public class Code04_PlaindromeWays {
    /**
     * 给定一个字符串str，当然可以生成很多子序列
     *   返回有多少个子序列是回文子序列，空序列不算回文
     *   比如，str = “aba”
     *   回文子序列：{a}、{a}、 {a,a}、 {b}、{a,b,a}
     *   返回5
     */
    
    /**
     * 思路: 范围尝试模型
     *  dp[L][R]: 在字符串中从L..R中所有子序列能搞出几个回文来，所有字符任意选择，子序列不要求连续, 空串不算。
     *            如果能搞定这个问题，那么毫无疑问，最右上角 0 到 N 减1，就是我们要的。 dp[0][N-1]就是答案。
     *            
     *  都已经告诉你是范围上的尝试了，所以往往讨论开头，结尾如何如何去划分可能性。
     *  可能性划分:
     *   1) 回文子序列一定不选择L, 一定不选择R位置的字符, 有a个回文
     *   2) 回文子序列一定选择L, 一定不选R位置的字符 b个
     *   3) 回文子序列一定不选L, 一定选择R位置的字符 c个
     *   4) 回文子序列一定选择L, 一定选择R位置的字符 d个 (只有当L位置的字符等于R位置的字符的时候，才有这种情况)
     *   dp[L][R] = a + b + c + d
     *   
     *  而dp[L][R]和dp[L+1][R], dp[L][R-1], dp[L+1][R-1]三个值有关, 需要用这三个值加工出dp[L][R]。
     *      1.[L]位置字符!=[R]位置字符的情况, 如何求dp[L][R]:
     *         1) 先看看L位置的数不等于R位置的字符, 就是没有可能性4, dp[L][R] = a+b+c
     *         如何得到a+b+c?
     *         dp[L+1][R]: L+1 到R位置的字符任意选择，能搞出多少回文串？这个dp的对应的是: L位置一定不选，R位置可选可不选, 对应的是a+c
     *         dp[L][R-1]: L 到R-1位置的字符任意选择，能搞出多少回文串？这个dp的对应的是: R位置一定不选，L位置可选可不选, 对应的是a+b
     *         
     *         dp[L+1][R] + dp[L][R-1] = 2a + b + c 要得到a+b+c需要减去一个a
     *         
     *         2) a是回文子序列一定不选择L, 一定不选择R位置的字符情况下 L+1到R-1能够形成的回文数, 也就是dp[L+1][R-1]
     *         
     *         3) 所以可以得到在[L]位置字符!=[R]位置字符的情况下,dp[L][R] = dp[L+1][R] + dp[L][R-1] - dp[L+1][R-1]
     *         
     *      2.[L]位置字符==[R]位置字符的情况, 如何求dp[L][R]:
     *        1)L位置的字符等于R位置的字符，所以L+1到R-1位置上任意选择，能够形成的回文, 在怼上L位置和R位置的字符，一定是回文:
     *        dp[L][R] = dp[L+1][R-1]
     *        够了吗？
     *        2)如果L+1...R-1这个范围哪怕是个空串, 包上L位置跟R位置的字符也能构成一种情况, 所以需要再加1
     *        
     *        3)所以[L]位置字符==[R]位置字符的情况下, dp[L][R]: dp[L][R] = dp[L+1][R-1] + 1
     *      
     * 例子: 看笔记, 上面的状态转移其实是通过例子得到的，一定可以自己搞出来，举几个例子，只不过时间可能长一些。  
     */
    public static int ways(String str) {
        if(str == null || str.length() == 0) {
            return 0;
        }
        char strChs[] = str.toCharArray();
        int N = strChs.length;
        // L~R 范围尝试，L到R的范围都是0~N-1
        int dp[][] = new int[N][N];
        // 对角线填法
        // 填好主对角线，全是1，因为主对角线只有一个字符，天然就是一个回文串
        for(int i = 0; i <= N - 1; i++) {
            dp[i][i] = 1;
        }
        // 填好第二条对角线，相邻的两个字符，任意选择，能够构成多少个回文
        // 如果相邻的字符相等，就是3个，如果不相等，就是2个
        for(int i = 0; i <= N - 2; i++) {
            dp[i][i+1] = strChs[i] == strChs[i + 1] ? 3 : 2;
        }
        // 从第三条对角线，一条条填好
        // 从下往上斜着填
        for(int L = N - 3; L >= 0; L--) { // 这里的下标变换，举例子去推，然后直接记住
            for(int R = L + 2; R <= N - 1; R++) {
                dp[L][R] += dp[L+1][R] + dp[L][R-1] - dp[L+1][R-1];
                if(strChs[L] == strChs[R]) { // L和R位置的字符相等
                    dp[L][R] += dp[L+1][R-1] + 1;
                }
            }
        }
        return dp[0][N - 1];
    }
}
