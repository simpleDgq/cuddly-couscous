package class33;

// 238. 除自身以外数组的乘积
public class Problem_0238_ProductOfArrayExceptSelf {
    /**
     * 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
     * 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
     * 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。
     * 
     * 示例 1:
     * 输入: nums = [1,2,3,4]
     * 输出: [24,12,8,6]
     * 
     * 示例 2:
     * 输入: nums = [-1,1,0,-3,3]
     * 输出: [0,0,9,0,0]
     */
    
    /**
     * 思路:   索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案
     * ans数组，从后往前，乘起来，填在ans数组对应的位置
     * 例如[2, 2, 3, 4, 1, 4] -> ans数组最后一位就是[..., 4]
     * -> ans数组倒数第二位就是[...1 * 4, 4]
     * -> ans数组倒数第三位就是[...4 * 1 * 4, 1 * 4, 4]
     * ..
     * 搞好ans数组
     * 
     * 从左往右，记录一个变量，表示左边的乘积，当来到一个位置的时候，这个数左边的乘积维护好，
     * 这个数右边的乘积ans辅助数组里面有，乘起来，就是i位置的数
     * 
     * 例如: [2, 2, 3, 4, 1, 4]
     * 来到1位置，左边的乘积是1 * 2, 右边可以从ans中取
     * 
     */
    public int[] productExceptSelf(int[] nums) {
        
        int length = nums.length;
        int ans[] = new int[length];
        // 从右往左，填好ans数组
        ans[length - 1] = nums[length - 1];
        for(int i = length - 2; i >= 0; i--) {
            ans[i] = nums[i] * ans[i + 1];
        }
        /*
         * [1, 2, 3, 4] ->[24, 24 ,12, 4]
         */
        
        // 从左往右
        int left = 1;// i位置左边部分的乘积，从1开始，因为0位置左边没有数
        ans[0] = ans[1];// [24, ... ]
        
        for(int i = 1; i <= length - 1; i++) {
            left *= nums[i - 1];
            if(i == length - 1) {
                ans[i] =  left;
            } else {
                ans[i] = left * ans[i + 1]; 
            }
        }
        return ans;
    }
    
    /**
     * 此题还可以扩展
     * 如果不能申请额外的空间
     * 
     * 思路:
     * 遍历一遍数组，所有不是0的位置的数乘在一起。
     * 1. 数组中有1个0，那么只有0所在的位置有值，其它位置都是0，0位置的两边的数乘起来，填在0位置就行(上面遍历得到的乘积直接填下来就行)
     * 2. 数组中有2个及以上的0，则答案中全部都填上0
     * 3. 数组中没有0，假设所有不是0的位置的乘积是a，假设1位置的数是b，那么1位置的答案应该是a/b
     * 假设2位置的数是c，那么1位置的答案应该是a/c
     * ...
     * 但是不能用除法, 使用位运算代替除法 --> 新手班
     */
}
