package class34;

// 289. 生命游戏
// https://leetcode.cn/problems/game-of-life/
public class Problem_0289_GameOfLife {
    /**
     * 根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
     * 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 
     * 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
     *  1)如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
     *  2)如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
     *  3)如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
     *  4)如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
     *  下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。
     *  
     *  给你 m x n 网格面板 board 的当前状态，返回下一个状态。
     */
    
    /**
     * 思路:
     * 
     * 1.简单做法: 搞一个辅助矩阵，计算每一个格子下一轮状态，然后记录到辅助数组中返回 --> 空间复杂度高
     * 
     * 2.上面的解法空间复杂度高
     * 原始格子的值是int，有32位，其实可以用原始格子数的倒数第2位来代表下一轮的状态，
     * 老的状态用最后一位表示
     * 
     * 逻辑:
     * 遍历每一个格子，分别计算邻居数
     * 如果邻居数是3，或者当前格子是存活状态（是1）且当前格子的邻居数是2，那么下一轮，这个格子都会存活，
     * 将当前格子数的第2位，变成1，记录下一轮的状态
     * 所有的格子的值往右移动一位，就是下一轮的初始状态
     * 
     */
    public void gameOfLife(int[][] board) {
        int M = board.length;
        int N = board[0].length;
        for(int i = 0; i <= M - 1; i++) {
            for(int j = 0; j <= N - 1; j++) {
                int neighbors = neighbors(i, j, board);
                // 如果邻居数是3，或者当前格子是存活状态（是1）且当前格子的邻居数是2，那么下一轮，这个格子都会存活，
                // 将当前格子数的第2位，变成1，记录下一轮的状态
                if(neighbors == 3 || (board[i][j] == 1 && neighbors == 2)) {
                    board[i][j] |= 2; // 或上2，就将第二位变成了1
                }
            }
        }
        // 所有的格子的值往右移动一位，就是下一轮的初始状态
        for(int i = 0; i <= M - 1; i++) {
            for(int j = 0; j <= N - 1; j++) {
                board[i][j] >>= 1;
            }
        }
    }
    
    /**
     * 获取i,j位置的邻居有多少个1
     */
    public int neighbors(int i, int j, int[][] b) {
        // 8个方向统计
        return f(b, i - 1, j - 1)
                + f(b, i - 1, j)
                + f(b, i - 1, j + 1)
                + f(b, i, j - 1)
                + f(b, i, j + 1)
                + f(b, i + 1, j - 1)
                + f(b, i + 1, j)
                + f(b, i + 1, j + 1);
    }
    
    /**
     * board[i][j]是1就返回1，是0就返回0
     * 
     * 判断的时候需要用最后一位判断原始的状态
     */
    public int f(int[][] board, int i, int j) {
        // 不越界且最后一位是1就返回1，否则返回0
        return (i >=0 && i <= board.length - 1 && j >= 0 && j <= board[0].length - 1 && (board[i][j] & 1) == 1) ? 1 : 0;
    }
    
}
