package class16;

// https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/
public class Code05_JosephusProblem {
    /**
     *  约瑟夫环问题
     *  剑指 Offer 62. 圆圈中最后剩下的数字
     *  
     *   0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
     *   例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
     *
     */
    
    /**
     * 思路:
     * 
     * 一直删，最终只会存在一个节点，如果存在一个函数，我告诉它节点被删之后的编号，它能返回这个节点被删之前的编号
     * 最后存活的节点被删之后的编号是1，调用这个函数就能够知道，存活的节点的在只有2个节点的时候的编号；继续往上调用，能够得到只有3个节点的时候，存活下来的
     * 节点的编号；继续往上调，一直往前调用到一个节点也不杀的时候(也就是n个节点的时候)的编号就是幸存编号，答案找到了。
     * 
     * 目标就是: 推导一个F函数, 告诉我杀之后的编号怎么对应出杀之前的编号
     * 
     * 先解决一个问题:
     *   编号和报数之间的关系，g函数传进来一个数字，我告诉你编号
     * 例子:
     * 编号: 1 2 3 4  四个节点
     * 报数: 从1开始报数，1 2 3 4, 对应1 2 3 4 四个节点,  报5的时候，回到1节点，6，回到2节点...
     * 
     * 节点编号与报数之间有一个对应关系。画图(参考笔记) --> 剃刀感觉的图像
     * 都可以通过移动
     * Y = X % i  来推出
     * 
     * 移动方向:
     * 左加右减，上加下减
     * 得到节点编号与报数之间的关系
     * Y = (X - 1) % i + 1
     * 给你一个数字(报数)，它减 1 之后模上i 再加1，就得到了它的编号
     * 节点编号 = (报数 - 1) % i + 1
     * 
     * 杀之后的编号怎么推杀之前的编号？
     * 例子:
     * 假设i个节点, 杀报数到m的编号, i = 7, m = 3
     * 
     * 1 2 3 4 5 6 7
     * 5 6 x 1 2 3 4  --> 杀死报数为3的号 --> (杀之后编号，杀之前编号) --> (1,4) (2,5) (3,6) (4,7) (5,1) (6,2) --> 画图
     * 2 3 x 4 5 x 1  --> 杀死新的报数为3的号 --> (杀之后编号，杀之前编号) --> (4,1) (5,2) (1,4) (2,5) (3,6) --> 画图
     * 
     * 画出图像之后，进行延长，限制死定义域  并不会影响最终结果
     *     发现又是剃刀图像。可以通过Y = (X - 1) % i + 1  来推出
     * Y = (X - 1) % i + 1  向左移动S位就能搞定(这个可以通过画图得到) --> S就是报数为m，被杀死的数的编号
     * 
     * 所以 杀之后的编号和推杀之前的编号 满足公式: Y = (X - 1 + S) % i + 1
     * 
     ** --> 表示推出
     * 报数和编号又有一个对应关系: 节点编号 = (报数 - 1) % i + 1 --> S = (m - 1) % i + 1
     * 
     * 代入Y = (X - 1 + S) % i + 1 --> Y = (X - 1 + (m - 1) % i + 1) % i + 1 --> Y = (X + (m - 1) % i) % i + 1 
     * 
     * 继续化简可以得到: Y = (X + m - 1) % i + 1
     * m - 1 = k * i + r, r表示(m - 1) / i的余数, 代入Y = (X + (m - 1) % i) % i + 1  --> Y = (X +  (k*i + r) % i) % i + 1 
     * -->k*i % 外面的i肯定是0, --> Y = (X + r % i) % i + 1  --> r % i 还是r， 继续推出Y = (X + r) % i + 1
     * 
     * 
     * Y = (X + m - 1) % i + 1
     * 将 m - 1 = k * i + r代入上面的公式，Y = (X + k * i + r) % i + 1 ，  k * i % i = 0 所以继续得到Y = (X + r) % i + 1
     * 和61行得到的结果相同
     * 
     * 说明两个公式是等价的。
     * 
     * 最终我们就得到了杀之后的编号怎么推杀之前的编号 ======> Y = (X + m - 1)  % i + 1, i表示当前剩下的节点数
     * 
     */  
    public int lastRemaining(int n, int m) {
        // 这里减1，是因为leetcode是从编号是从0开始的，而我们的求解是从1开始的，最终的编号会比LeetCode大1，所以减去1，就能够过leetcode
        return getLive(n, m) - 1; // 返回一个数也不删的时候的，最后存活的那个节点的编号，就是答案
    }
    // 返回只有n个节点的时候，最后存活的节点，所在的编号
    public int getLive(int n, int m) {
        if(n == 1) { // 只有一个节点的时候，存活的节点的编号就是1
            return 1;
        }
        // getLive(n - 1, m): 得到杀之后, 也就是n个节点杀之后, n - 1个节点的时候，存活的节点对应的编号
        // 然后通过公式: (getLive(n - 1, m) + m - 1) % n + 1 就能得到杀之前，也就是n个节点的时候，存活的节点对于的编号，就是答案
        return (getLive(n - 1, m) + m - 1) % n + 1;
    }

}
