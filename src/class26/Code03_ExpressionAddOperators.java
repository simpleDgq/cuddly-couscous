package class26;

import java.util.ArrayList;
import java.util.List;

//本题测试链接 : https://leetcode.cn/problems/expression-add-operators/
public class Code03_ExpressionAddOperators {
    /**
     * 给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。

        示例 1:
        
        输入: num = "123", target = 6
        输出: ["1+2+3", "1*2*3"] 
        示例 2:
        
        输入: num = "232", target = 8
        输出: ["2*3+2", "2+3*2"]
        示例 3:
        
        输入: num = "105", target = 5
        输出: ["1*0+5","10-5"]
        示例 4:
        
        输入: num = "00", target = 0
        输出: ["0+0", "0-0", "0*0"]
        示例 5:
        
        输入: num = "3456237490", target = 9191
        输出: []
        
        提示：
        
        0 <= num.length <= 10
        num 仅含数字
     */
    
    /**
     * 思路:
     * 1. 你来到i位置的时候，你决定前面的符号到底是不添还是添+还是添-还是添*，可能性就是这么划分
     * 
     * 
     * 2. 搞一个辅助数组path，沿途做过的决定，放在path里面。
     * 
     * 字符串567210, 一共6个字符, 你可以在56之间, 67之间, 72之间, 21之间, 10之间
     * 或者添-, 或者添+,或者添*,或者不添符号, 最终的结果最长是11
     * 你最多这个长度最大，就是每个空都填上的符号，它也不会超过11长度
     * 
     * 有一个原始字符串不动, 做过的决定保留到一个辅助数组, 所以如果要递归的话，我们就得有两个指针，
     *       第1个指针表是原始数组中你来到了啥位置
     *       第2个指针就是你沿途做过的决定填到了什么位置
     *       
     * 3. 怎么计算出path里面最终的结果？ 可以解析整个表达式，计算出结果，但是麻烦，如何快速计算？
     * 
     * 想快速计算
        F函数里需要加参数
        我标记了你 number 走到了哪个index，我也标记了你路径填到了什么位置。我想办法，我增加一些信息。
        当我 index 来到整个number结尾的时候，我这个附加信息能告诉我，我算算出来的结果是多少，我就
        不用再把path里这个东西转成一个公式，再算出这个公式有多少？我想达到这样的目的，我怎么设计这个参数？
        我可以到最后算，我也可以想办法增加一些中间过程，增加一些参数。到最后的时候，我能够迅速确定它的值是多少。
     * 
     * 搞两个变量，left和cur
     * 
     *  left: 绝对不会改变的部分
     *   cur:可能改变的部分，有可能因为你之前填的这个符号被改变的部分
        
     *   例子: 5 + 2 + 3 * 4 ? 7   当前来到了7，7之前填什么符号？
     *   left = 5 + 2 = 7 是不管7之前填什么符号，left都不会改变
     *   cur = 3 * 4 = 12 7之前填不同的符号cur可能会改变
     *   
     *   例子: 5 + 4 - 7 * 2  ? 4 当前来到了4，4之前填什么符号？
     *   left = 5 + 4 = 9 绝对不会变的地方
     *   cur = -7 * 2 = -14 可能会改变的地方
     *      1) 假设4前面填+号，对于4后面的过程来说，left = 9 - 14 = -5， cur = 4, 如果到4后终止了, 结束了, 最终结果就是left+cur= -5 + 4 = -1
     *      2) 假设4前面填-号，对于4后面的过程来说，left = 9 - 14 = -5， cur = -4, 如果到4后终止了, 结束了, 最终结果就是left+cur= -5 - 4 = -9
     *      3) 假设4前面填*号，对于4后面的过程来说，left = 9， cur = -7 * 2 * 4 = -56, 如果到4后终止了, 结束了, 最终结果就是left+cur= 9 - 56 = -47
     *   既考虑了优先级有能快速计算出答案。
     *   
     * 一开始怎么办?
     *   例子5412这个数， 来到4了, 4前面决定填什么符号, 第一个数是5, 现在来到4, left默认为0, cur=5
     *  
     *  例子: 假设来到4位置, 4之前必须填符号, left = 100, cur = 20
     *  1) 如果4之前填+ 号: 对于4后面的过程来说，不变的部分left是100+20 = 120， 可能改变的部分cur是4 -> 如果4位置是结束位置，那么最终的结果就是120 + 4
     *  2) 如果4之前填- 号: 对于4后面的过程来说，不变的部分left是100+20 = 120， 可能改变的部分cur是-4-> 如果4位置是结束位置，那么最终的结果就是120 - 4
     *  3) 如果4之前填* 号: 对于4后面的过程来说，不变的部分left是100， 可能改变的部分cur是20 * 4= 80->  如果4位置是结束位置，那么最终的结果就是100 + 80
     *  
     *  4. 每个数之前可以填符号，也可以不填，讨论了每个数之前都必须填的情况，怎么解决不填的问题？
     *  
     *  例子: 1213
     *  现在假设来到i位置
     *  1) 我第一个部分就是1, 下面轮到 1 位置必须在前面填符号做决定
     *  2) 我第一个部分就是12, 下面轮到 2 位置必须在前面填符号做决定
     *  3) 我第一个部分就是121, 下面轮到 3 位置必须在前面填符号做决定
     *  
     *  
     *  大思路:
     *  1.尝试0~i位置作为第一部分的所有情况，第一部分先填好，来到i+1位置，必须在前面填符号，递归搞定
     *  2.递归中，当前来到了index位置，index~N-1位置，每一个可能的前缀作为第一部分都尝试一遍
     */
    public List<String> addOperators(String num, int target) {
        if(num == null || num.length() == 0) {
            return null;
        }
        List<String> res = new ArrayList<String>();
        int N = num.length();
        char path[] = new char[2 * N - 1];
        char nums[] = num.toCharArray();
        int len = 0;
        long n = 0; // 用long，防止越界。例如 num = "2147483648" 
                                       // target = -2147483648
        // 0~i作为第一部分都去试一遍
        for(int i = 0; i <= N - 1; i++) {
            n = n * 10 + nums[i] - '0';
            path[len++] = nums[i]; // i位置的数填到path中
            // i+1位置后续过程递归去搞
            process(res, path, len, 0, n, nums, i + 1, target);
            if(n == 0) {
                break; // 不能有01，03这种类似的数字作为前缀的情况
            }
        }
        return res;
    } 
    
    // 搜集到的答案放在res中
    // path: 之前做的决定，已经从左往右依次填写的字符在其中，可能含有'0'~'9' 与 * - +
    // len: path[0..len-1]已经填写好，len是终止
    // left: 前面固定的部分
    // cur: 前面可变的部分
    // num: 原始字符数组
    // index: 字符类型数组num, 使用到了哪
    // aim: 目标值
    // 当前来到了num的index位置，index位置怎么做决定？index出发，每一个前缀作为第一部分，都搞一遍
    public void process(List<String> res, char path[], int len, 
            long left, long cur,
            char num[], int index, int aim) {
        // 如果原始字符数组使用完了, 
        if((index == num.length)) {
            if(left + cur == aim) //path中的表达式搞出来的结果正好是aim，收集答案
                res.add(new String(path, 0, len)); // 0 ~ len - 1都填好了, 只取填好的部分
            return; // 到达了末尾，搞完了，必须要返回
        }
        long n = 0;// 第一部分的值
        int j = len + 1;
        // 如果不是结束位置，index位置之前必须填符号
        // index出发，每一个前缀作为第一部分，都搞一遍
        for(int i = index; i <= num.length - 1; i++) {
            // 计算出第一部分, num[index...i]作为第一部分
            n = n * 10 + num[i] - '0';
            // i位置怎么做决定
            path[j++] = num[i]; // i位置填到path中  
            // 第一部分之前填+号, i+1位置递归去搞
            path[len] = '+';
            process(res, path, j, left + cur, n, num ,i + 1,aim);
            // 第一部分之前填-号
            path[len] = '-';
            process(res, path, j, left + cur, -n, num ,i + 1,aim);
            // 第一部分之前填*号
            path[len] = '*';
            process(res, path, j, left, cur * n, num ,i + 1,aim);
            if (num[index] == '0') {
                break;
            }
            /**
             * index==0的时候, break
                如果第一个位置是0, 只有一种可能性
                就是第一个部分只有 0 这个数字下一个位置填+-*, 只走一遍
                你不能选01做第一个数字，你也不能选 013 做第一个数字
                为你在添符号的时候，任何一个数字，它不能有前缀0
                没有第二个前缀，因为不允许出现前缀。
                index~index做为第一个数字, 填一遍+-*, 没有后续了
             */
        }
    }
    
    
    public static void main(String[] args) {
        char[] test = {'a', 'b'};
        System.out.println(test.toString()); //[C@15db9742
        System.out.println(new String(test)); // "a,b"
    }
}
