package class14;

//测试链接：https://leetcode.com/problems/first-missing-positive/
public class Code04_FirstMissingNumber {
    // 缺失的第一个正数  时间复杂度O(N) 空间复杂度: O(1)
    /** 
        给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
        请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
    
        示例 1：
    
        输入：nums = [1,2,0]
        输出：3
        示例 2：
    
        输入：nums = [3,4,-1,1]
        输出：2
        示例 3：
    
        输入：nums = [7,8,9,11,12]
        输出：1
        提示：
    
        1 <= nums.length <= 5 * 10^5
        -2^31 <= nums[i] <= 2^31 - 1
    */
    
    /**
     * 字节考法
     * 无序数组, 有正, 负, 零, >K的情况下哪个正整数缺且最小
     * 把所有数减个K就是一个题
     */
    
    /**
     * 思路:
     * 
     * 搞一个有效区和垃圾区:
     * 
     * 1) 有效区里面i位置放的是i+1这个数，有效区用L表示，L的左边是有效区，刚开始有效区一个数也没有，L处于0位置
     * 垃圾区: 不在需要的数进垃圾区，刚开始，垃圾区处于越界位置，表示垃圾区没有扩住任何一个位置, 垃圾区为空
     * 垃圾区从R开始
        R两个含义:
        垃圾区左边界
        我现在一个数也没有看过, 我有没有最好的预期, 收集的结果能让我返回值尽量大的预期
        R+1就是此时最好预期
      例子 : [0 1 2 3 4 5 6]  --> 1~6每一个数只收你一个，而且一个数字也不缺，预期能够得到的最大值是R+1=7, 
     * 2)
     * 1.如果来到的L位置的数是L+1，说明是有效的，有效区右扩;
     * 2.假设L来到17位置, 说明0~16位置上，1 ~ 17都搜集好了 (看笔记的例子);
     *    1) 如果17位置的数 <= 17, 说明17位置的数是垃圾，应该进入垃圾区，和垃圾区的第一个数交换，R--  -> 抽象: ? <= L 的数垃圾, 已经收集过的数字会让最好情况变差
     *    2) 如果17位置的数 > 31, 现在预期的最大值是32, 说明只要搜集完1-31所有的数，这时候，L位置的数>31了，肯定是垃圾，和垃圾区的第一个数交换，R--
     *    3) 如果17位置的数 是 23， 该去的位置其实是22， 如果22位置的数也是23，说明17位置的数是垃圾，也要进入垃圾区 --> arr[L] == arr[arr[L]-1]
     * 3. 如果17位置的数 是 23，该去的位置其实是22，如果22位置的数不是23，17位置的数和22位置的数交换   
     * 4.最后L会和R碰到一起，返回L+1就是答案。
     */
    public int firstMissingPositive(int[] nums) {
        if(nums == null || nums.length == 0) {
            return 0;
        }
        int N = nums.length;
        
        int L = 0;
        int R = N;
        int cur = 0;
        while(L != R) {
            cur = nums[L];
            if(cur == L + 1) {
                L++;
            } else if(cur <= L || cur > R || cur == nums[cur - 1]) {
                swap(L, --R, nums);
            } else {
                swap(L, cur - 1, nums);
            }
        }
        return L + 1;
    }
    
    public void swap(int i, int j, int arr[]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
