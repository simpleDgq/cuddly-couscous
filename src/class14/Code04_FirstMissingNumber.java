package class14;

//测试链接：https://leetcode.com/problems/first-missing-positive/
public class Code04_FirstMissingNumber {
    // 缺失的第一个正数 时间复杂度O(N) 空间复杂度: O(1)
    /**
     * 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
     * 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
     * 
     * 示例 1：
     * 
     * 输入：nums = [1,2,0]
     * 输出：3
     * 示例 2：
     * 
     * 输入：nums = [3,4,-1,1]
     * 输出：2
     * 示例 3：
     * 
     * 输入：nums = [7,8,9,11,12]
     * 输出：1
     * 提示：
     * 
     * 1 <= nums.length <= 5 * 10^5
     * -2^31 <= nums[i] <= 2^31 - 1
     */

    /**
     * 字节考法
     * 无序数组, 有正, 负, 零, >K的情况下哪个正整数缺且最小
     * 把所有数减个K就是一个题
     */

    /**
     * 思路:
     * i位置应该放i+1
     * 
     * 搞一个有效区和垃圾区:
     * 
     * 1) 有效区里面i位置放的是i+1这个数，有效区用L表示，L的左边是有效区，刚开始有效区一个数也没有，L处于0位置
     * 垃圾区: 不在需要的数进垃圾区，刚开始，垃圾区处于数组越界位置，表示垃圾区没有扩住任何一个位置, 垃圾区为空
     * 垃圾区从R开始
     * R两个含义:
     * 垃圾区左边界
     * 我现在一个数也没有看过, 我有没有最好的预期, 收集的结果能让我返回值尽量大的预期
     * R+1就是此时最好预期
     * 例子 : [0 1 2 3 4 5 6] --> 1~6每一个数只收你一个，而且一个数字也不缺，预期能够得到的最大值是R+1=7,
     * 2)
     * 1.如果来到的L位置的数是L+1，说明是有效的，有效区右扩;
     * 2.假设L来到17位置, 说明0~16位置上，1 ~ 17都搜集好了 (看笔记的例子);
     * 1) 如果17位置的数 <= 17, 说明17位置的数是垃圾，应该进入垃圾区，和垃圾区的第一个数交换，R-- -> 抽象: ? <= L 的数垃圾,
     * 已经收集过的数字会让最好情况变差
     * 2) 如果17位置的数 > R 31, 现在预期的最大值是32,
     * 说明只要搜集完1-31所有的数，这时候，L位置的数>31了，肯定是垃圾，和垃圾区的第一个数交换，R--
     * 3) 如果17位置的数 是 23， 该去的位置其实是22， 如果22位置的数也是23，说明17位置的数是垃圾，也要进入垃圾区 --> arr[L] ==
     * arr[arr[L]-1]
     * 3. 如果17位置的数 是 23，该去的位置其实是22，如果22位置的数不是23，17位置的数和22位置的数交换
     * 4.最后L会和R碰到一起，返回L+1就是答案。
     */
    public int firstMissingPositive2(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int N = nums.length;

        int L = 0;
        int R = N;
        int cur = 0;
        while (L != R) {
            cur = nums[L];
            if (cur == L + 1) {
                L++;
            } else if (cur <= L || cur > R || cur == nums[cur - 1]) {
                swap(L, --R, nums);
            } else {
                swap(L, cur - 1, nums);
            }
        }
        return L + 1;
    }

    public void swap(int i, int j, int arr[]) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * leetcode解法比较容易理解记忆一点
     * 
     * 如果数组中包含 x∈[1,N]，那么恢复后，数组的第 x−1 个元素为 x。    --> 也就是说i位置，应该放i+1这个数
     * 
     * 在恢复后，数组应当有 [1, 2, ..., N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二
     * [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。
     * 
     * 那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历，对于遍历到的数 x=nums[i]，如果 x∈[1,N]，我们就知道 x 应当出现在数组中的
     * x−1 的位置，因此交换 nums[i] 和 nums[x−1]，这样 x 就出现在了正确的位置。在完成交换后，新的 nums[i] 可能还在 [1,N]
     * 的范围内，我们需要继续进行交换操作，直到 x∈ [1,N]。
     * 
     * 注意到上面的方法可能会陷入死循环。如果 nums[i] 恰好与 nums[x−1] 相等，那么就会无限交换下去。此时我们有
     * nums[i]!=nums[x−1]，说明 x 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。
     * 
     * 由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 N，整个方法的时间复杂度为 O(N)。
     */
    public int firstMissingPositive(int[] nums) {
        /**
         * leetcode解法比较容易理解记忆一点
         * 
         * 如果数组中包含 x∈[1,N]，那么恢复后，数组的第 x−1 个元素为 x。 --> 也就是说i位置，应该放i+1这个数
         * 
         * 在恢复后，数组应当有 [1, 2, ..., N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二
         * [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。
         * 
         * 那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历，对于遍历到的数 x=nums[i]，如果 x∈[1,N]，我们就知道 x 应当出现在数组中的
         * x−1 的位置，因此交换 nums[i] 和 nums[x−1]，这样 x 就出现在了正确的位置。在完成交换后，新的 nums[i] 可能还在 [1,N]
         * 的范围内，我们需要继续进行交换操作，直到 x∈ [1,N]。
         * 
         * 注意到上面的方法可能会陷入死循环。如果 nums[i] 恰好与 nums[x−1] 相等，那么就会无限交换下去。此时我们有
         * nums[i]!=nums[x−1]，说明 x 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。
         * 
         * 由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 N，整个方法的时间复杂度为 O(N)。
         */
        if (nums == null || nums.length == 0) {
            return 0;
        }
        // 遍历每一个数，放在正确的位置
        int N = nums.length;
        for (int i = 0; i <= N - 1; i++) {
            // i位置应该放i+1, 所以这个数的范围必须是>=1 && <= N的
            // 如果nums[i] - 1位置上已经是nums[i]了，说明nums[i]被放到了正确的位置
            // 跳出循环，搞下一个数
            while (nums[i] >= 1 && nums[i] <= N && nums[i] != nums[nums[i] - 1]) {
                swap(i, nums[i] - 1, nums);
            }
        }
        // 放好之后，遍历数组，看哪个i位置不是i+1，i+1就是第一个确实的正数
        for (int i = 0; i <= N - 1; i++) {
            if(nums[i] != i+1) {
                return i + 1;
            }
        }
        // 每一个i位置都是i+1, 说明1~N都是全的
        return N + 1;
    }
}
