package class14;

//本题测试链接 : https://leetcode.com/problems/longest-valid-parentheses/
public class Code01_Parentheses {
    // 32. 最长有效括号
    /**
     * 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
        示例 1：
        
        输入：s = "(()"
        输出：2
        解释：最长有效括号子串是 "()"
        示例 2：
        
        输入：s = ")()())"
        输出：4
        解释：最长有效括号子串是 "()()"
        示例 3：
        
        输入：s = ""
        输出：0
        提示：
        0 <= s.length <= 3 * 10^4
        s[i] 为 '(' 或 ')'
     */
    
    
    
    /**
     * 子串问题：
     * 以i位置结尾的情况下，最长有效括号是多少？每一个位置求一个答案，然后取所有答案的最大值
     * 1. i位置是左括号，以左括号结尾的串，没有右括号能与它匹配，所以是无效的，答案是0
     * 如果i位置是右括号，得看它前面的i-1位置，能往前推多远，
     * 假设能够推到K位置，如果K位置是一个右括号，和i位置没法匹配，那么当前i位置就是无效的
     * 2. 如果k位置是一个左括号，那么i位置的答案至少是dp[i - 1] + 2, 然后害的看K - 1位置
     * 能往前推多远，加起来，才是i位置最终的答案

     dp[i]: 以i位置结尾的情况下，最长有效括号是多少？
     */
    public int longestValidParentheses(String s) {
        if(s == null || s.length() == 0) {
            return 0;
        }
        int N = s.length();
        char str[] = s.toCharArray();
        int dp[] = new int[N];
        int max = 0;
        // dp[0] = 0; // 0位置结尾，不能形成有效括号，答案是0，默认就是0，不用管
        for(int i = 1; i <= N - 1; i++) {
            if(str[i] == ')') { // 只有以右括号结尾的情况下，才有可能形成有效括号
               int K = i - dp[i - 1] - 1; // 看i - 1位置能够往左推到的最远位置
               if(K >= 0 && str[K] == '(') { // K位置是左扩号，加上i位置的右括号，才有可能形成有效括号串
                    dp[i] = dp[i - 1] +  2; // 至少是i-1位置的答案 + i位置和k位置的括号
                    if(K - 1 >= 0 && dp[K - 1] != 0) { // 如果K - 1位置能继续往前推
                        dp[i] += dp[K - 1];
                    }
               }
                max = Math.max(max, dp[i]);
            }
        }
        return max;
    }

}
