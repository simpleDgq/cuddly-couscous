package class37;

// 221. 最大正方形
// https://leetcode.cn/problems/maximal-square/description/
public class Problem_0221_MaximalSquare {
    /**
     * 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
     */
    /**
     * 思路: 动态规划
     * 
     * 如果能够求出正方形必须以6行7列的1做为右下角，最大能有多大?
     * 换而言之，如果我们能够求出以每一个i行j列的位置的1作为右下角，最大能有多大，
     * 每一个位置都求出一个最大能有多大，求个max，答案就出来了
     * 
     * 每一个i,j位置怎么求? dp[i][j]: 以i,j位置的1作为右下角，最大的正方形是多大？
     * 
     * 假设以最右下角的1出发有一个4*4的正方形，那么需要满足的条件是
     * 1. 这个1的左上角的1出发，最大必须是一个3 * 3的正方形
     * 2. 这个1的左边的1出发，最大必须是一个3 * 3的正方形
     * 3. 这个1的上边的1出发，最大必须是一个3 * 3的正方形
     * 
     * 假设当前1的左边的1出发最大的正方形是8*8，
     * 当前1的上边的1出发最大的正方形是6*6，
     * 当前1的左上的1出发最大的正方形是5*5
     * 那么当前的dp[i][j]可以从左边，上边，左上最大的正方形推出
     * 
     * 三者取最小 + 1，就是dp[i][j]  -->  这个结论得自己举例子得出来
     * 
     * 例如:
     * 
     * 1 1 1 1 1
     * 1 1 1 1 1
     * 1 1 1 1 1
     * 
     * 左边的1，最大是4 * 4
     * 左上的1，最大是2 * 2
     * 上边的，最大是2 * 2
     * 
     * 所以右下角的1出发，最大是3 * 3
     * 
     * 也就是三者取最小值，然后 + 1
     * 
     * 
     * 动态规划:
     * dp[i][j]: 以i,j位置的1作为右下角，最大的正方形是多大？
     * 
     * i的范围0 ~ N - 1
     * j的范围0 ~ M - 1
     * 
     * dp[N][M]
     * 
     */
    public int maximalSquare(char[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int N = matrix.length;
        int M= matrix[0].length;
        int dp[][] = new int[N][M];
        int max = 0;
        // 先填好第一行和第一列，因为它们没有上或者没有左上或者没有左
        // 填好第一列
        for(int i = 0; i <= N - 1; i++) {
            if(matrix[i][0] == '1') { // 只有一个格子能形成1*1的正方形
                dp[i][0] = 1;
                max = 1;
            }
           
        }
        // 填好第一列
        for(int j = 0; j <= M - 1; j++) {
            if(matrix[0][j] == '1') {
                dp[0][j] = 1;
                max = 1;
            }
        }
        // 从上往下从左往右填
        for(int i = 1; i <= N -1; i++) {
            for(int j = 1; j <= M -1; j++) {
                // 左，左上，上，三者取最小值
                if(matrix[i][j] == '1') {
                    dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                    max = Math.max(max,dp[i][j]);// 更新max
                }
            }
        }
        return max * max;
    }
}
