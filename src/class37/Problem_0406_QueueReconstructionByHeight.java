package class37;

import java.util.ArrayList;
import java.util.Arrays;

// 406. 根据身高重建队列
// https://leetcode.cn/problems/queue-reconstruction-by-height/description/
public class Problem_0406_QueueReconstructionByHeight {
    /**
     * 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。
     * 每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
     * 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，
     * 其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
     * 
     * 示例 1：
     * 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
     * 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
     * 解释：
     * 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
     * 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
     * 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
     * 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
     * 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
     * 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
     * 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
     * 
     * 示例 2：
     * 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]
     * 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
     */
    
    /**
     * 思路:
     * 
     * 1.将people数组排序，身高大的排前面，如果身高一样，则第二维小的排前面
     * 2.排好序之后，从头开始遍历，分别插入， 每个第二维就是要插入的位置
     * 
     * 课上用的是有序表自己实现的size balance tree，比较复杂，但是时间复杂度低(不想掌握了)
     * logN级别
     * 
     * 直接用O(N^2)的解法
     * 
     * 例子:
     * [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]
     * 
     * 排序之后:
     * [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]
     * 
     * 然后遍历，第二维是要插入的位置
     * 第1步[6,0]  <-[6,0]插到0位置
     * 第2步[5,0],[6,0] <-[5,0]插到0位置
     * 第3步[4,0],[5,0],[6,0] <-[4,0]插到0位置
     * 第4步[4,0],[5,0],[3,2],[6,0] <-[3,2]插到2位置
     * 第5步[4,0],[5,0],[2,2],[3,2],[6,0] <-[2,2]插到2位置
     * 第6步[4,0],[5,0],[2,2],[1,4],[3,2],[6,0] <-[1,4]插到4位置->答案
     * 
     * 
     * 关键是排序： 首先按照身高降序，k值升序排序（身高优先） 然后把第i个人插入到队伍的第k个位置即可。 
     * 因为身高已经降序排序好，所以先插入的身高一定比后插入的高，所以后插入的直接插在第k个位置就行，
     * 这样是满足k的含义的（前面的身高大于等于该位置人的人数）
     * 
     */
    public int[][] reconstructQueue(int[][] people) {
        if(people == null || people.length == 0 || people[0] == null || people[0].length == 0) {
            return null;
        }
        // 第一维身高不相等的时候，按第一维身高降序排列，相等的时候，按第二维升序排列
        Arrays.sort(people, (x, y) -> x[0] != y[0] ? y[0] - x[0] : x[1] - y[1]);
        // 搞一个ArrayList，依次插入
        ArrayList<int []> ans = new ArrayList<int []>();
        for(int i = 0; i <= people.length - 1; i++) {
            ans.add(people[i][1], people[i]); // add方法插入的时候，如果i位置已经有元素了，会自动往右调整
        }
        // toArray的时候，可以指定参数，返回对应形式的数组？
        return ans.toArray(new int[0][0]);
    }
    
    
}
