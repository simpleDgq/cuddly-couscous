package class35;

// 395. 至少有 K 个重复字符的最长子串
// https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/description/
public class Problem_0395_LongestSubstringWithAtLeastKRepeatingCharacters {
    /**
     * 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。
     * 如果不存在这样的子字符串，则返回 0。
     * 
     * s 仅由小写英文字母组成
     */
    
    /**
     * 思路: 
     * 题目给出了s仅由小写英文字母组成。小写英文字母只有26个，利用它
     * 
     * 大流程:
     * 整个串中，子串必须只包含1种字符，每一种次数都大于等于k，多长
     * 整个串中，子串必须只包含2种字符，每一种次数都大于等于k，多长
     * 整个串中，子串必须只包含3种字符，每一种次数都大于等于k，多长
     * ......
     * 整个串中，子串必须只包含26种字符，每一种次数都大于等于k，多长
     * 
     * 每一种要求，只需要遍历一遍字符串搞定，时间复杂度就是O(N)
     * 
     * 所有的结果取最大值就是答案
     * 
     * 
     * 
     * // 记录a~z 出现次数
     * int[] count = new int[26];
     * 
     * // 记录目前窗口内收集了几种字符了, 怎么计算
     * 假设窗口已经形成了，现在里面有a出现了1次，b出现了2次，d出现了3次，下一个字符是c，还没有出现过，出现的次数是0
     * 那么c进来之后，窗口中字符的种类就加1
     * 同理，往外吐字符的时候，如果吐出的字符出现的次数是1，那么吐出之后窗口中字符的种类就减1
     * int collect = 0; 
     * 
     * // 目前窗口内出现次数>=k次的字符，有多少种
     * int satisfy = 0;
     * 进来字符的时候，如果进来的字符+1之后等于k，那么窗口类出现次数>=k次的字符的数量+1
     * 如果进来的字符+1之后大于或者小于k，窗口类出现次数>=k次的字符的数量不变
     *  
     * 滑动窗口过程:
     * L尝试每一个位置出发，
     * R一直往右扩，R还有下一个元素
     * 
     * 不能往右扩的情况: 如果当前窗口内搜集到的字符种类等于要求的种类，而且下一个遇到的字符词频是0，
     * 加进来之后，搜集到的字符的种类就大于要求的种类了，所以不能再往右扩
     * 
     *      
     * 能扩的情况下:
     *      如果加进来的字符出现的次数是0，加进来之后，窗口内字符的种类数+1
     *      如果加进来的字符出现的次数是k-1，加进来之后，次数变成1，窗口内符合出现次数>=k次字符的种类数也要+1
     * 不能扩的情况下:
     *      如果当前窗口内符合出现次数>=k次的字符种类等于要求的种类，说明当前窗口是一个答案，搜集答案，否则不是一个答案
     *      然后吐出字符，L++，如果吐出的字符的次数是1，吐出之后，该窗口内就没有这个字符了，所以当前窗口内字符种类数-1
     *      如果吐出的字符的次数是k，吐出之后，该窗口内符合出现次数>=k次字符的种类数也要-1
     *      
     * 
     * for套while，L，R不回退，O(N)
     */
    public static int longestSubstring(String s, int k) {
        if(s == null || s.length() == 0) {
            return 0;
        }
        int ans = 0;
        char str[] = s.toCharArray();
        int N = str.length;
        for(int require = 1; require <= 26; require++) { // 必须有require种字符
            int count[] = new int[26]; // 当前窗口内，a~z字符出现的次数
            int collect = 0; // 目前窗口内，搜集到的字符种类
            int satisfy = 0; // 目前窗口内，满足出现次数>=k次的字符种类
            
            int R = 0;
            for(int L = 0; L <= N - 1; L++) { // L要尝试每一个位置出发的所有窗口
                // 什么情况下可以一直往下扩？
                // 1.当前窗口里面的字符种类没有达到要求的种类
                // 2.当前窗口里面的字符种类达到了要求的种类，但是下一个字符在当前窗口内已经出现过，词频不是0，加入进去，窗口能变大
                // 答案也能变大
                // !(collect == require && count[str[R + 1] - 'a'] == 0  -> 左神写法
                // R还有下一个元素，而且当前窗口里面的字符种类没有达到要求的种类，则一直往下扩
                // R指向的元素还没有进入区间，要满足条件才能进入，R等于N-1的时候，指向最后一个元素，也需要判断是否进入区间
                while(R <= N - 1 && ((collect != require) || (collect == require && count[str[R] - 'a'] != 0))) {
                    if(count[str[R] - 'a'] == 0) { // 如果要进入窗口的元素，出现的次数是0，来了新的字符，搜集到的字符种类数++
                        collect++;
                    }
                    // 如果加进来之前，出现的词频数是k-1，那么加进来之后，当前窗口内符合出现次数>=k次的字符种类数++
                    if(count[str[R] - 'a'] == k - 1) {
                        satisfy++;
                    }
                    // 词频++
                    count[str[R] - 'a']++;
                    
                    R++;
                    System.out.println("collect: " + collect);
                    System.out.println("require: " + require);
                    System.out.println("R: " + R);
                }
                // 不能扩了
                // 如果当前窗口内，满足出现次数>=k次的字符种类satisfy == 要求的种类，说明是一个答案，pk出max
                if(require == satisfy) {
                    // R指向的位置是要判断的下一个字符，不是有效的区间内，L~R-1才是有效的区间
                    ans = Math.max(ans, R - L); 
                    System.out.println("R: " + R);
                }
                // 左边窗口吐出元素，L++
                // 吐出元素的时候，如果元素的词频是1，吐出之后，就是0了，那么新的窗口内，搜集到的元素的种类就要减1
                if(count[str[L] - 'a'] == 1) {
                    collect--;
                }
                // 如果吐出的元素，出现的次数是k，吐出之后，那么新的窗口内，这个字符出现的词频就是k-1了，那么
                // 目前窗口内，满足出现次数>=k次的字符种类就要减1
                if(count[str[L] - 'a'] == k) {
                    satisfy--;
                }
                // 词频--
                count[str[L] - 'a']--;
            }
        }
        return ans;
    }
    
    /*
     * aaabb
     * k = 3
     */
    public static void main(String[] args) {
        longestSubstring("aaabbb", 3);
    }
}
