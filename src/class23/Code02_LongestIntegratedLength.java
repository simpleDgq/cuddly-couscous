package class23;

import java.util.HashSet;

public class Code02_LongestIntegratedLength {
    /**
     * 最大可整合子数组的长度
     * 
     *定义什么是可整合数组：
        一个数组排完序之后，除了最左侧的数外，有arr[i] = arr[i-1]+1
        则称这个数组为可整合数组
        比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组
        返回arr中最长可整合子数组的长度

        先给出可整合数组的定义:如果一个数组在排序之后，每相邻两个数差的绝对值 都为 1，
         则该数组为可整合数组。例如，[5,3,4,6,2]排序之后为[2,3,4,5,6]， 
         符合每相邻两个数差的绝对值 都为 1，所以这个数组为可整合数组。
          给定一个整型数组 arr，请返回其中最大可整合子数组的长度。
          例如， [5,5,3,2,6,4,3]的最大 可整合子数组为[5,3,2,6,4]，所以返回 5。
     * 
     */
    
    /**
     * 思路:
     * 1. 可能会想到暴力方法，对于每一个子数组，总共有O(N^2)个子数组，都拷贝出来(因为求得是原数组中最大可整合数组的长度，不能改变原数组，所以得拷贝出来)
     *    然后判断这个子数组是不是可整合的，判断的时候先排序，时间复杂度最好就是O(N*logN)，排序后验证相邻两个元素差是不是1，需要
     *    O(N)的时间复杂度，最终的时间复杂度就是O(N^3*logN)
     *    
     * 优化:重新定义最大可整合数组
     *  1. 数组无重复值
     *  2. 数组的max-min = 数组的元素个数-1  (数组连续，最大值减最小值需要等于元素个数-1)
     * 验证子数组是否是可整合的时候就可以将时间复杂度降为O(1) --> 整体的时间复杂度降为O(N^2)
     */
    public static int maxLen(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int N = arr.length;
        // 记录已经进入过子数组范围的数
        HashSet<Integer> set = new HashSet<Integer>();
        int ans = 1; // 一个元素的时候，最大可整合数组长度就是1, 至少都有1这个兜底的答案
        for(int L = 0; L <= N - 1; L++) {
            // 每一个新的L开始的时候，都是新的子数组开始，注意要情况set
            set.clear();// !!!!
            
            // 记录最大最小
            int max = arr[L];
            int min = arr[L];
            
            // 子数组出现过的元素加入set
            set.add(arr[L]);
            
            // R从L+1开始，因为一个元素的时候，最大可整合数组长度就是1
            for(int R = L + 1; R <= N - 1; R++) {
                // 如果有重复的，直接break
                if(set.contains(arr[R])) {
                    break; // 直接break, 开始下一个L
                }
                // 没有重复过的元素，记得加入set
                set.add(arr[R]);
                
                // 更新max和min
                max = Math.max(max, arr[R]);
                min = Math.min(min, arr[R]);
                // 判断子数组是否满足最大值-最小值 = 元素个数 - 1
                if(max - min == R - L) { // 元素个数是R- L+ 1, 还要减1，所以计算R - L
                    // 如果是可整合数组，看能不能推高答案
                    ans = Math.max(ans, R - L + 1);
                }
            }
        }
        return ans;
    }
}
