package class03;

//本题测试链接 : https://leetcode.cn/problems/longest-substring-without-repeating-characters/
public class Code03_LongestSubstringWithoutRepeatingCharacters {

    /**
     * 求一个字符串中，最长无重复字符子串长度
     * 
     * 思路:
     * 这就是所谓的你看到任何一个关于什么子串问题，还是子数组问题
     * 先这么想，这个答案你甭管它问的是啥，这道题是最长无重复子串，是最长无重复这个事儿，
     * 下回一个别的问题叫S问题，只要是子串子数组的问题，你就想0结尾的时候这个s答案是啥？
     * 1结尾的时候这个s答案是啥，就这么想，这是我们的一个重要思维传统
     * 
     * 1. 必须以0结尾的情况下左侧推多远能不重复求答案，
     * 子串必须以1结尾的情况下左侧推多远能不重复求个答案，
     * 子串必须与二结尾的时候左侧最多能推多远能不重复求答案，
     * 如果我们每个位置结尾的时候往左侧往左侧能推多远不重复的答案都求出来，
     * 所有答案中的最大值就是我要的
     * 2. 答案是从左往右求的当我来到i位置的时候，i-1位置的答案你求过了, i-2位置的答案你求过了,
     * i-3位置的答案你求过了，那么我就想我i结尾时的答案能不能由我之前求出答案帮我加速得到，
     * 为啥要把求解流程定位每个位置结尾或每个位置开头，我就是想用动态规划
     * 3. i号位置，假如是a字符，它能往前推多远，取决于两个因素：
     * 1) a上次出现的位置
     * 2) i-1号位置能够往前推到的位置
     * 两者取最小值
     * 4. 不需要整张动态规划表
     * 因为i位置只需要i-1位置的答案, 并不需要左边所有的那些答案
     * 在推i位置的时候, 只需要i-1位置的答案, 你用有限几个变量滚动跟下去就可以了，
     * 你没有必要准备整个dp数组
     */

    public int lengthOfLongestSubstring(String s) {
        /**
         * 子串，子数组问题
         * 通用思路： 以i位置结尾，答案是啥？
         * 
         * 必须以0结尾的情况下左侧推多远能不重复求答案，
         * 子串必须以1结尾的情况下左侧推多远能不重复求个答案，
         * 子串必须与二结尾的时候左侧最多能推多远能不重复求答案，
         * 如果我们每个位置结尾的时候往左侧往左侧能推多远不重复的答案都求出来，
         * 所有答案中的最大值就是我要的
         * 
         * 2. 答案是从左往右求的当我来到i位置的时候，i-1位置的答案你求过了, i-2位置的答案你求过了,
         * i-3位置的答案你求过了，那么我就想我i结尾时的答案能不能由我之前求出答案帮我加速得到，
         * 为啥要把求解流程定位每个位置结尾或每个位置开头，我就是想用动态规划
         * 
         * 3. i号位置，假如是a字符，它能往前推多远，取决于两个因素：
         * 1) a上次出现的位置 搞一个数组记录a上次出现的位置
         * 2) i-1号位置能够往前推到的位置
         * 两者取最小值
         */
        if (s == null || s.length() == 0) {
            return 0;
        }
        if (s.length() == 1) {
            return 1;
        }
        int N = s.length();
        // 记录每个字符上一次出现的位置
        int map[] = new int[256];
        char arr[] = s.toCharArray();

        // 初始化map, -1表示没有出现过
        for (int i = 0; i <= N - 1; i++) {
            map[arr[i]] = -1;
        }

        // 0位置的字符出现的位置
        map[arr[0]] = 0;
        // 0 位置往前没有字符了，能求到的最大长度就是1
        int pre = 1; // 前一个字符往前推，能够得到的答案
        int ans = 1; // 至少答案是1
        // 每个i位置结尾，看能不能推高答案
        for (int i = 1; i <= N - 1; i++) {
            // 可能性1 ： i 减去 i位置的字符上一次出现的位置
            int p1 = i - map[arr[i]];
            if (map[arr[i]] == -1) { // 说明i - 1位置的字符以前没有出现过，那么答案就完全由i-1位置决定
                p1 = Integer.MAX_VALUE;
            }
            // 可能性2: i - 1位置往前推能够搞出的最大长度，加上当前i位置长度1
            int p2 = pre + 1;
            // 更新i位置的字符出现的位置
            map[arr[i]] = i;
            // i++之前记录，当前i字符往前推，能够得到的最长子串的长度
            pre = Math.min(p1, p2);
            // 看能不能推高答案
            ans = Math.max(pre, ans);
        }
        return ans;
    }
}
