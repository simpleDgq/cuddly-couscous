package class27;

// https://leetcode.cn/problems/reverse-integer/?favorite=2ckc81c
public class Problem_0007_ReverseInteger {
    /**
     * 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

        如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。
        假设环境不允许存储 64 位整数（有符号或无符号）。
     */
    
    /**
     * 思路:
     *   不要用string类型(转成string，然后反转，然后再转成int，面试0分)
     *   目的就是想让你一个整数，用有限几个变量搞出来
     *   会有转换不了的问题, 比如系统最大, 翻转以后会溢出返回0
     *
     *   一个比较重要的技巧:
     *   面对转换问题, 转成负数考虑, 因为系统最小值绝对值比最大值大一个, 拿它做底更安全
     *   (比如转换字符串 “-2147483648”用正数处理就不够了)
     *   
     *  每次消一位:
     *  例如-123， 模10之后是 -3, -123 / 10 = -12
     *  再模10, 是-2,  -3*10 + (-2) = -32, -12 / 10 = -1
     *  再模10, 是-1,  -32*10 + (-1) = -321
     *  
     *  
     *  如何判断溢出？
     *  1) res结果是负数, 如果比系统最小/10 还小, 那么乘10之后必溢出
     *  2) 如果res等于系统最小/10, 则乘10之后不溢出, 但是模出来的数x%/10如果小于系统最小模10, 则加上这部分必溢出
     */
    
    public int reverse(int x) {
        // 判断是否是负数，如果不是搞成负数
        boolean neg = ((x >> 31) & 1) == 1; // 右移31位，符号位和1与，如果结果是1，则是负数，否则是正数
        // 如果是正数搞成负数
        x = neg ? x : -x;
        int res = 0;
        int m = Integer.MIN_VALUE / 10;
        int o = Integer.MIN_VALUE % 10;
        while(x != 0) {
            // 判断是否溢出
            // res结果是负数, 如果比系统最小/10 还小, 那么乘10之后必溢出
            // 如果res等于系统最小/10, 则乘10之后不溢出, 但是模出来的数x%/10如果小于系统最小模10, 则加上这部分必溢出
            if(res < m || (res == m && x % 10 < o) ) {
                return 0;
            }
            res = res * 10 + x % 10;   
            x /= 10;
        }
        // 如果x本身是负数，那么直接返回res，否则x是正数，返回res的绝对值，也就是返回正数答案
        return neg ? res : Math.abs(res);
    }
}
